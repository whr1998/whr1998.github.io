<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>初识RxJS与demo实践</title>
    <link href="/2022/07/15/%E5%88%9D%E8%AF%86RxJS%E4%B8%8Edemo%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/07/15/%E5%88%9D%E8%AF%86RxJS%E4%B8%8Edemo%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<img src="/2022/07/15/%E5%88%9D%E8%AF%86RxJS%E4%B8%8Edemo%E5%AE%9E%E8%B7%B5/titleImg.jpg" class="" title="新兰永恒 image"><h3 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h3><blockquote><p>RxJS 中 Stream 的概念：将不断产生的数据或事件组成序列称作 Stream。</p></blockquote><p>1.Observable：被观察的对象，代表未来可能产生的数据或事件的集合。</p><p>2.Observer：观察者，通常是回调函数，用来接收观察结果。其中包括三个属性（next，complete、error）。</p><p>3.Subscription：订阅对象，用于建立 Observer 与 Observable 的联系（也可以取消订阅）。</p><p>4.operators：运算符，对 Observable 产生的数据或事件进行处理的纯函数。常见的运算符有 map、filter、delay 等。</p><p>5.Subject：主体，如同 EventEmitter，用于将 Observable 广播给多个 Observer。在这种情况下，Subject 即是 Observer 又是 Observable。</p><img src="/2022/07/15/%E5%88%9D%E8%AF%86RxJS%E4%B8%8Edemo%E5%AE%9E%E8%B7%B5/subject%E5%B9%BF%E6%92%AD%E5%9B%BE.jpg" class="" title="Subject广播关系图 image"><h3 id="二、第一个示例"><a href="#二、第一个示例" class="headerlink" title="二、第一个示例"></a>二、第一个示例</h3><p>通常，原生 js 采用如下方式注册事件监听。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">document.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;Clicked!&#x27;</span>));<br></code></pre></td></tr></table></figure><p>使用 RxJS 可以创建 Observable。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> &#123; fromEvent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><br>fromEvent(document, <span class="hljs-string">&#x27;click&#x27;</span>).subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;Clicked!&#x27;</span>));<br></code></pre></td></tr></table></figure><h3 id="三、Demo"><a href="#三、Demo" class="headerlink" title="三、Demo"></a>三、Demo</h3><h5 id="1-安装-RxJS"><a href="#1-安装-RxJS" class="headerlink" title="1.安装 RxJS"></a>1.安装 RxJS</h5><p>因为只是跑简单示例，所以并没有用构建工具初始化项目。创建 HTML 文件，采用 CDN 引入的方式使用 RxJS。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const &#123; &#125; <span class="hljs-operator">=</span> rxjs<span class="hljs-comment">; // 使用ES6解构赋值按需引入</span><br>const &#123; &#125; <span class="hljs-operator">=</span> rxjs.operators<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果构建项目，则需要使用 <strong>npm install rxjs</strong>来安装 RxJS。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>; <span class="hljs-comment">// 采用import语法引入</span><br><span class="hljs-keyword">import</span> &#123; &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="2-例子一：监听点击事件并输出前三次的数据。"><a href="#2-例子一：监听点击事件并输出前三次的数据。" class="headerlink" title="2.例子一：监听点击事件并输出前三次的数据。"></a>2.例子一：监听点击事件并输出前三次的数据。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; fromEvent &#125; = rxjs;<br><span class="hljs-keyword">const</span> &#123; take &#125;  = rxjs.<span class="hljs-property">operators</span>;<br><br><span class="hljs-keyword">let</span> btnDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.btn&quot;</span>);<br><span class="hljs-title function_">fromEvent</span>(btnDom, <span class="hljs-string">&#x27;click&#x27;</span>).<span class="hljs-title function_">pipe</span>(<br>    <span class="hljs-title function_">take</span>(<span class="hljs-number">3</span>)<br>).<span class="hljs-title function_">subscribe</span>(<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span><br>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    其中fromEvent(btnDom, &#x27;click&#x27;) 为 Observable；</span><br><span class="hljs-comment">    take(3) 为 Operators；</span><br><span class="hljs-comment">    console.log 为 Observer</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h5 id="3-例子二：点击按钮延时三秒输出结果。"><a href="#3-例子二：点击按钮延时三秒输出结果。" class="headerlink" title="3.例子二：点击按钮延时三秒输出结果。"></a>3.例子二：点击按钮延时三秒输出结果。</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; fromEvent &#125; = rxjs;<br><span class="hljs-keyword">const</span> &#123; take, delay &#125; = rxjs.<span class="hljs-property">operators</span>;<br><br><span class="hljs-keyword">let</span> btnDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.btn&quot;</span>);<br><span class="hljs-title function_">fromEvent</span>(btnDom, <span class="hljs-string">&#x27;click&#x27;</span>).<span class="hljs-title function_">pipe</span>(<br>    <span class="hljs-title function_">delay</span>(<span class="hljs-number">3000</span>),<br>    <span class="hljs-title function_">take</span>(<span class="hljs-number">3</span>)<br>).<span class="hljs-title function_">subscribe</span>(<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击按钮后延时三秒输出&quot;</span>);<br>    &#125;<br>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    其中fromEvent(btnDom, &#x27;click&#x27;) 为 Observable；</span><br><span class="hljs-comment">    delay(3000), take(3) 为 Operators；</span><br><span class="hljs-comment">    () =&gt; &#123;</span><br><span class="hljs-comment">        console.log(&quot;点击按钮后延时三秒输出&quot;);</span><br><span class="hljs-comment">    &#125; 为 Observer</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="部分内容来自RxJS-官方文档"><a href="#部分内容来自RxJS-官方文档" class="headerlink" title="部分内容来自RxJS 官方文档"></a>部分内容来自<a href="https://rxjs.dev/">RxJS 官方文档</a></h4>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>RxJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-解构赋值之对象</title>
    <link href="/2022/07/12/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E4%B9%8B%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/07/12/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E4%B9%8B%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<img src="/2022/07/12/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E4%B9%8B%E5%AF%B9%E8%B1%A1/titleImg.jpg" class="" title="新兰永恒 image"><h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">let &#123; foo, bar &#125; = &#123; foo: <span class="hljs-string">&#x27;aaa&#x27;</span>, bar: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>foo <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;aaa&quot;</span><br>bar <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;bbb&quot;</span><br></code></pre></td></tr></table></figure><p><strong><em>（1）对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</em></strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">let &#123; baz &#125; = &#123; foo: <span class="hljs-string">&#x27;aaa&#x27;</span>, bar: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>baz <span class="hljs-regexp">//</span> undefined<br></code></pre></td></tr></table></figure><p>（2）对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 例一</span><br>let &#123; <span class="hljs-built_in">log</span>, <span class="hljs-built_in">sin</span>, <span class="hljs-built_in">cos</span> &#125; = Math;<br><br><span class="hljs-comment">// 例二</span><br>const &#123; <span class="hljs-built_in">log</span> &#125; = <span class="hljs-built_in">console</span>;<br><span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">// hello</span><br>~~~<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-解构赋值之数组</title>
    <link href="/2022/07/12/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <url>/2022/07/12/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<img src="/2022/07/12/ES6-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E4%B9%8B%E6%95%B0%E7%BB%84/titleImg.jpg" class="" title="新兰永恒 image"><h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><p>（1）ES6 可以从数组中提取值，按照对应位置，对变量赋值。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">let <span class="hljs-comment">[a, b, c]</span> = <span class="hljs-comment">[1, 2, 3]</span>;<br></code></pre></td></tr></table></figure><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。<br>其他的解构例子如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">let [foo, [[bar], baz]] = [<span class="hljs-number">1</span>, [[<span class="hljs-number">2</span>], <span class="hljs-number">3</span>]];<br>foo <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>bar <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>baz <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>let [ , , third] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>third <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>let [head, ...tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>head <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>tail <span class="hljs-regexp">//</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>（2）如果解构不成功，变量的值就等于 undefined。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">let <span class="hljs-comment">[foo]</span> = <span class="hljs-comment">[]</span>;<br>let <span class="hljs-comment">[bar, foo]</span> = <span class="hljs-comment">[1]</span>;<br></code></pre></td></tr></table></figure><p>（3）另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">let [x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>x <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>y <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>let [a, [b], d] = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>];<br>a <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>b <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>d <span class="hljs-regexp">//</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>（4）如果等号的右边不是数组（或者说不是可遍历的结构），那么将会报错。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 报错<br>let [foo] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> false<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> NaN<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> undefined<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。<br>（5）Set 结构可以解构赋值，实际上，只要某种数据结构具有 Iterator 接口，就可以采用数组形式的解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [x, y, z] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]);<br>x <span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></td></tr></table></figure><h2 id="二、默认值"><a href="#二、默认值" class="headerlink" title="二、默认值"></a>二、默认值</h2><p>（1）解构赋值允许指定默认值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">let [foo = true] = [];<br>foo <span class="hljs-regexp">//</span> true<br><br>let [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-regexp">//</span> x=<span class="hljs-string">&#x27;a&#x27;</span>, y=<span class="hljs-string">&#x27;b&#x27;</span><br>let [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>, undefined]; <span class="hljs-regexp">//</span> x=<span class="hljs-string">&#x27;a&#x27;</span>, y=<span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>注意：只有当数组成员严格等于 undefined，默认值才会生效，使用严格相等运算符（&#x3D;&#x3D;&#x3D;）来判断是否 undefined。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>] <span class="hljs-operator">=</span> [undefined]<span class="hljs-comment">;</span><br><span class="hljs-keyword">x</span> // <span class="hljs-number">1</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>] <span class="hljs-operator">=</span> [<span class="hljs-keyword">null</span>]<span class="hljs-comment">;</span><br><span class="hljs-keyword">x</span> // <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span>不严格等于undefined<br></code></pre></td></tr></table></figure><p>（2）如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> [x = <span class="hljs-title function_">f</span>()] = [<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// 等价于如下代码</span><br><br><span class="hljs-keyword">let</span> x;<br><span class="hljs-keyword">if</span> ([<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>) &#123;<br>  x = <span class="hljs-title function_">f</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  x = [<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）默认值可以引用解构赋值的其他变量，但必须已经声明。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> []<span class="hljs-comment">;     // x=1; y=1</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">2</span>]<span class="hljs-comment">;    // x=2; y=2</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span>]<span class="hljs-comment">; // x=1; y=2</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> y<span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-number">1</span>] <span class="hljs-operator">=</span> []<span class="hljs-comment">;     // ReferenceError: y is not defined</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-let和const（下）</title>
    <link href="/2022/07/11/ES6-let%E5%92%8Cconst%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2022/07/11/ES6-let%E5%92%8Cconst%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<img src="/2022/07/11/ES6-let%E5%92%8Cconst%EF%BC%88%E4%B8%8B%EF%BC%89/2.png" class="" title="image"><h2 id="一、const-基本用法"><a href="#一、const-基本用法" class="headerlink" title="一、const 基本用法"></a>一、const 基本用法</h2><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-literal">PI</span> = <span class="hljs-number">3.1415</span>;<br><span class="hljs-literal">PI</span> <span class="hljs-comment">// 3.1415</span><br><span class="hljs-literal">PI</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// TypeError: Assignment to constant variable.</span><br></code></pre></td></tr></table></figure><p>const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> foo; <span class="hljs-comment">// SyntaxError: Missing initializer in const declaration</span><br></code></pre></td></tr></table></figure><p>const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。const 声明的常量，也与 let 一样不可重复声明。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  const <span class="hljs-built_in">MAX</span> = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-built_in">MAX</span> <span class="hljs-comment">// Uncaught ReferenceError: MAX is not defined</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">MAX</span>); <span class="hljs-comment">// ReferenceError</span><br>  const <span class="hljs-built_in">MAX</span> = <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hello!&quot;</span>;<br>let age = <span class="hljs-number">25</span>;<br><span class="hljs-comment">// 以下两行都会报错</span><br>const message = <span class="hljs-string">&quot;Goodbye!&quot;</span>;<br>const age = <span class="hljs-number">30</span>;<br>~~~<br></code></pre></td></tr></table></figure><h2 id="二、本质"><a href="#二、本质" class="headerlink" title="二、本质"></a>二、本质</h2><p>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p><p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><p>简言之,const 保证简单类型数据变量指向的内存地址的数据不变,保证复杂类型数据所指向的内存地址中的地址不变,而数据结构是否变化则不能保证.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">const foo = &#123;&#125;;<br><span class="hljs-regexp">//</span> 为 foo 添加一个属性，可以成功<br>foo.prop = <span class="hljs-number">123</span>;<br>foo.prop <span class="hljs-regexp">//</span> <span class="hljs-number">123</span><br><span class="hljs-regexp">//</span> 将 foo 指向另一个对象，就会报错<br>foo = &#123;&#125;; <span class="hljs-regexp">//</span> TypeError: <span class="hljs-string">&quot;foo&quot;</span> is read-only<br></code></pre></td></tr></table></figure><h2 id="三、ES6-声明变量的六种方法"><a href="#三、ES6-声明变量的六种方法" class="headerlink" title="三、ES6 声明变量的六种方法"></a>三、ES6 声明变量的六种方法</h2><p>ES5: var 和 function<br>ES6: var function let const import class</p><h2 id="四、顶层对象"><a href="#四、顶层对象" class="headerlink" title="四、顶层对象"></a>四、顶层对象</h2><p>顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p><p>(1) 没法在编译时就报出变量未声明的错误，只有运行时才能知道<br>(2) 容易不知不觉地就创建了全局变量<br>(3) 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。<br>(4) window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = <span class="hljs-number">1</span>;<br><span class="hljs-regexp">//</span> 如果在 Node 的 REPL 环境，可以写成 global.a<br><span class="hljs-regexp">//</span> 或者采用通用方法，写成 this.a<br>window.a <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>let b = <span class="hljs-number">1</span>;<br>window.b <span class="hljs-regexp">//</span> undefined<br></code></pre></td></tr></table></figure><h4 id="五、globalThis-对象"><a href="#五、globalThis-对象" class="headerlink" title="五、globalThis 对象"></a>五、globalThis 对象</h4><p>(1) 顶层对象在各种实现里面是不统一的。</p><p>浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window。<br>浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self。<br>Node 里面，顶层对象是 global，但其他环境都不支持。</p><p>(2) 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 this 变量，但是有局限性。</p><p>全局环境中，this 会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。<br>函数里面的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this 会指向顶层对象。但是，严格模式下，这时 this 会返回 undefined。<br>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么 eval、new Function 这些方法都可能无法使用。</p><p>ES2020 在语言标准的层面，引入 globalThis 作为顶层对象。也就是说，任何环境下，globalThis 都是存在的，都可以从它拿到顶层对象，指向全局环境下的 this。</p><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-let.md">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-let和const（上）</title>
    <link href="/2022/07/11/ES6-let%E5%92%8Cconst%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2022/07/11/ES6-let%E5%92%8Cconst%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<img src="/2022/07/11/ES6-let%E5%92%8Cconst%EF%BC%88%E4%B8%8A%EF%BC%89/titleImg.jpg" class="" title="新兰永恒 image"><h1 id="let-关键字与-const-关键字"><a href="#let-关键字与-const-关键字" class="headerlink" title="let 关键字与 const 关键字"></a>let 关键字与 const 关键字</h1><p>let 关键字和 const 关键字是 ES6 新增的用于变量定义的新特性</p><h2 id="一、-let-声明的变量只在块级作用域有效"><a href="#一、-let-声明的变量只在块级作用域有效" class="headerlink" title="一、 let 声明的变量只在块级作用域有效"></a>一、 let 声明的变量只在块级作用域有效</h2><p>块级作用域大概可以理解为一对花括号{}内</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&#123;<br>let a1 = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> b1 = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;a1&quot;</span> + a1); <span class="hljs-comment">// ReferenceError: a is not defined.</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;b1&quot;</span> + b1); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="let-适用于-for-循环中的变量定义"><a href="#let-适用于-for-循环中的变量定义" class="headerlink" title="let 适用于 for 循环中的变量定义"></a>let 适用于 for 循环中的变量定义</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i); <span class="hljs-comment">// ReferenceError: i is not defined</span><br></code></pre></td></tr></table></figure><h4 id="let-与-var-区别"><a href="#let-与-var-区别" class="headerlink" title="let 与 var 区别"></a>let 与 var 区别</h4><p>let 作用于块级，而 var 作用于全局，经过 for 循环，let 声明的 i 会取得 6，var 声明的 i 会取得全局的 10</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>for (var i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++) &#123;</span><br>  a[i] <span class="hljs-operator">=</span> function () &#123;<br>    console.log(i)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>&#125;<br>a[<span class="hljs-number">6</span>]()<span class="hljs-comment">; // 10</span><br><br>var a <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>for (let i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++) &#123;</span><br>  a[i] <span class="hljs-operator">=</span> function () &#123;<br>    console.log(i)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>&#125;<br>a[<span class="hljs-number">6</span>]()<span class="hljs-comment">; // 6</span><br></code></pre></td></tr></table></figure><h2 id="二、let-不存在变量提升"><a href="#二、let-不存在变量提升" class="headerlink" title="二、let 不存在变量提升"></a>二、let 不存在变量提升</h2><p>var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined。let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// var 的情况</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo); <span class="hljs-comment">// 输出undefined</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// let 的情况</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(bar); <span class="hljs-comment">// 报错ReferenceError</span><br>let bar = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h2 id="三、暂时性死区（temporal-dead-zone，简称-TDZ）"><a href="#三、暂时性死区（temporal-dead-zone，简称-TDZ）" class="headerlink" title="三、暂时性死区（temporal dead zone，简称 TDZ）"></a>三、暂时性死区（temporal dead zone，简称 TDZ）</h2><p>只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span><br>  <span class="hljs-keyword">let</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-comment">// TDZ开始</span><br>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp); <span class="hljs-comment">// ReferenceError</span><br>  let tmp; <span class="hljs-comment">// TDZ结束</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp); <span class="hljs-comment">// undefined</span><br>  tmp = <span class="hljs-number">123</span>;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp); <span class="hljs-comment">// 123</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样的设计是为了养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><h2 id="四、不允许重复声明"><a href="#四、不允许重复声明" class="headerlink" title="四、不允许重复声明"></a>四、不允许重复声明</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 报错</span><br><span class="hljs-function">function <span class="hljs-title">func</span>()</span> &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 报错</span><br><span class="hljs-function">function <span class="hljs-title">func</span>()</span> &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不能在函数内部重新声明参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> <span class="hljs-keyword">func</span>(arg) &#123;<br>  let arg;<br>&#125;<br><span class="hljs-keyword">func</span>() <span class="hljs-regexp">//</span> 报错<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">func</span>(arg) &#123;<br>  &#123;<br>    let arg;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">func</span>() <span class="hljs-regexp">//</span> 不报错<br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://www.bookstack.cn/read/es6-3rd/spilt.1.docs-let.md">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
