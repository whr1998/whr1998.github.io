<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TS-类</title>
    <link href="/article/6f61a62.html"/>
    <url>/article/6f61a62.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在 ES6 以前，javascript 没有类的概念，因此实现继承等面向对象的操作就比较麻烦，只能基于函数以及原型链来实现。<br>从 ECMAScript 2015，也就是 ECMAScript 6 开始，JavaScript 程序员将能够使用基于类的面向对象的方式。</p><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Greeter</span> &#123;<br>    <span class="hljs-attr">greeting</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">message: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span> = message;<br>    &#125;<br>    <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">greeting</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> greeter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Greeter</span>(<span class="hljs-string">&quot;world&quot;</span>);<br></code></pre></td></tr></table></figure><p>声明了 Greeter 类，其中包含三个成员：greeting 属性、构造函数和 greet 方法，使用 this 来访问当前类的成员。使用 new 关键字构造了 Greeter 类的实例化对象 greeter，它会调用构造函数来创建实例对象，并初始化。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 TypeScript 里，我们可以使用常用的面向对象模式。基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    move(distanceInMeters: number = <span class="hljs-number">0</span>) &#123;<br>        console.log(`<span class="hljs-type">Animal</span> moved $&#123;distanceInMeters&#125;m.`);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    bark() &#123;<br>        console.log(&#x27;<span class="hljs-type">Woof</span>! <span class="hljs-type">Woof</span>!&#x27;);<br>    &#125;<br>&#125;<br><br>const dog = <span class="hljs-keyword">new</span> <span class="hljs-type">Dog</span>();<br>dog.bark();<br>dog.move(<span class="hljs-number">10</span>);<br>dog.bark();<br></code></pre></td></tr></table></figure><p>通过关键字 extends，使得派生类（子类）Dog 继承了基类（超类）Animal。因此创建的 dog 实例对象可以使用 bark()和 move()。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">theName: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = theName; &#125;<br>    <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.name&#125;</span> moved <span class="hljs-subst">$&#123;distanceInMeters&#125;</span>m.`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Snake</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">super</span>(name); &#125;<br>    <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">5</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Slithering...&quot;</span>);<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(distanceInMeters);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Horse</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Animal</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">super</span>(name); &#125;<br>    <span class="hljs-title function_">move</span>(<span class="hljs-params">distanceInMeters = <span class="hljs-number">45</span></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Galloping...&quot;</span>);<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">move</span>(distanceInMeters);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> sam = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Snake</span>(<span class="hljs-string">&quot;Sammy the Python&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">tom</span>: <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Horse</span>(<span class="hljs-string">&quot;Tommy the Palomino&quot;</span>);<br><br>sam.<span class="hljs-title function_">move</span>();<br>tom.<span class="hljs-title function_">move</span>(<span class="hljs-number">34</span>);<br></code></pre></td></tr></table></figure><p>使用 extends 创建了 Animal 的两个子类 Snake 和 Horse，都包含了一个构造函数，TS 做了限制，派生类中的构造函数必须调用 super(),这样会执行基类的构造方法。在构造函数里访问 this 的属性之前，一定要调用 super()。<br>两个子类都创建了 move()，并重写了从基类继承而来的 move()，使得 move()根据不同的类而具有不同的功能。</p><h2 id="public、private、protected、readonly"><a href="#public、private、protected、readonly" class="headerlink" title="public、private、protected、readonly"></a>public、private、protected、readonly</h2><ul><li>public<br>在 TS 中，类的成员默认都是使用 public 修饰符进行修饰，表示可以自由访问类的成员。</li><li>private<br>当成员被标记成 private 时，那么该成员在类的外部将不能被访问。</li><li>protected<br>protected 修饰符与 private 修饰符的行为很相似，但有一点不同， protected 成员在派生类中仍然可以访问。</li><li>readonly<br>使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</li></ul><h2 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h2><p>TypeScript 支持通过 getters&#x2F;setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> passcode = <span class="hljs-string">&quot;secret passcode&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> _fullName: <span class="hljs-built_in">string</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>(): <span class="hljs-built_in">string</span></span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._fullName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">set</span> <span class="hljs-title">fullName</span>(<span class="hljs-params">newName: <span class="hljs-built_in">string</span></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (passcode &amp;&amp; passcode == <span class="hljs-string">&quot;secret passcode&quot;</span>) &#123;<br>            <span class="hljs-keyword">this</span>._fullName = newName;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            console.log(<span class="hljs-string">&quot;Error: Unauthorized update of employee!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> employee = <span class="hljs-keyword">new</span> Employee();<br>employee.fullName = <span class="hljs-string">&quot;Bob Smith&quot;</span>;<br><span class="hljs-keyword">if</span> (employee.fullName) &#123;<br>    alert(employee.fullName);<br>&#125;<br><br><span class="hljs-comment">// 当密码不对时，会提示我们没有权限去修改员工。</span><br></code></pre></td></tr></table></figure><h2 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h2><p>之前定义的成员，都是类的实例成员，那些是仅当类被实例化的时候才会被初始化的属性，而如果要创建类的静态成员，则要使用 static 来定义，这些属性存在于类本身上面而不是类的实例上。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Grid &#123;<br>    static origin = &#123;x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>&#125;;<br>    calculate<span class="hljs-constructor">DistanceFromOrigin(<span class="hljs-params">point</span>: &#123;<span class="hljs-params">x</span>: <span class="hljs-params">number</span>; <span class="hljs-params">y</span>: <span class="hljs-params">number</span>;&#125;)</span> &#123;<br>        <span class="hljs-keyword">let</span> xDist = (point.x - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Grid</span>.</span></span>origin.x);<br>        <span class="hljs-keyword">let</span> yDist = (point.y - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Grid</span>.</span></span>origin.y);<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>sqrt(xDist<span class="hljs-operator"> * </span>xDist + yDist<span class="hljs-operator"> * </span>yDist)<span class="hljs-operator"> / </span>this.scale;<br>    &#125;<br>    constructor (public scale: number) &#123; &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> grid1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Grid(1.0)</span>;  <span class="hljs-comment">// 1x scale</span><br><span class="hljs-keyword">let</span> grid2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Grid(5.0)</span>;  <span class="hljs-comment">// 5x scale</span><br><br>console.log(grid1.calculate<span class="hljs-constructor">DistanceFromOrigin(&#123;<span class="hljs-params">x</span>: 10, <span class="hljs-params">y</span>: 10&#125;)</span>);<br>console.log(grid2.calculate<span class="hljs-constructor">DistanceFromOrigin(&#123;<span class="hljs-params">x</span>: 10, <span class="hljs-params">y</span>: 10&#125;)</span>);<br></code></pre></td></tr></table></figure><p>在这个例子里，我们使用 static 定义 origin，因为它是所有网格都会用到的属性。每个实例想要访问这个属性的时候，都要在 origin 前面加上类名。如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象类作为其它派生类的基类使用。它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-title">makeSound</span>(): <span class="hljs-keyword">void</span></span>;<br>    move(): <span class="hljs-keyword">void</span> &#123;<br>        console.log(<span class="hljs-string">&#x27;roaming the earch...&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract 关键字并且可以包含访问修饰符。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Department</span> &#123;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span></span>) &#123;<br>    &#125;<br><br>    <span class="hljs-title function_">printName</span>(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Department name: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-title function_">printMeeting</span>(): <span class="hljs-built_in">void</span>; <span class="hljs-comment">// 必须在派生类中实现</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AccountingDepartment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Department</span> &#123;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">super</span>(<span class="hljs-string">&#x27;Accounting and Auditing&#x27;</span>); <span class="hljs-comment">// 在派生类的构造函数中必须调用 super()</span><br>    &#125;<br><br>    <span class="hljs-title function_">printMeeting</span>(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The Accounting Department meets each Monday at 10am.&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">generateReports</span>(): <span class="hljs-built_in">void</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Generating accounting reports...&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">department</span>: <span class="hljs-title class_">Department</span>; <span class="hljs-comment">// 允许创建一个对抽象类型的引用</span><br>department = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Department</span>(); <span class="hljs-comment">// 错误: 不能创建一个抽象类的实例</span><br>department = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountingDepartment</span>(); <span class="hljs-comment">// 允许对一个抽象子类进行实例化和赋值</span><br>department.<span class="hljs-title function_">printName</span>();<br>department.<span class="hljs-title function_">printMeeting</span>();<br>department.<span class="hljs-title function_">generateReports</span>(); <span class="hljs-comment">// 错误: 方法在声明的抽象类中不存在</span><br></code></pre></td></tr></table></figure><h4 id="示例与内容来自TypeScript-文档"><a href="#示例与内容来自TypeScript-文档" class="headerlink" title="示例与内容来自TypeScript 文档"></a>示例与内容来自<a href="https://www.tslang.cn/docs/handbook/classes.html">TypeScript 文档</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS-接口</title>
    <link href="/article/54e7d36b.html"/>
    <url>/article/54e7d36b.html</url>
    
    <content type="html"><![CDATA[<img src="/article/54e7d36b/banner.jpg" class="" title="image"><h2 id="概念相关"><a href="#概念相关" class="headerlink" title="概念相关"></a>概念相关</h2><p>在面向对象编程语言中，接口通常用作对行为的抽象，然后使用类来实现这种行为。在 TS 中，接口则更为灵活，除了上述功能，还支持对<code>对象的形状</code>进行描述。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xquery">interface Person &#123;<br>   <span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> string</span>;<br>    age:<span class="hljs-built_in"> number</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> tom: Person = &#123;<br>   <span class="hljs-built_in"> name</span>: <span class="hljs-string">&#x27;Tom&#x27;</span>,<br>    age: <span class="hljs-number">24</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例子中定义了接口 Person 和变量 tom，而 tom 的<code>形状</code>需要严格遵循接口所设定的形状，tom 中多或少某个属性都是不允许的。</p><h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>接口中的属性不是必需的，可选属性在应用<code>option bags</code>模式时，给函数传入的参数对象中只有部分属性赋值了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">interface Person &#123;<br>  name: string;<br>  <span class="hljs-attribute">height</span>?: number;<br>&#125;<br><br>let jerry: Person = &#123;<br>    name: <span class="hljs-string">&#x27;Jerry&#x27;</span><br>    // height可以不传值<br>&#125;<br></code></pre></td></tr></table></figure><p>可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 Person 里的 height 属性名拼错，就会得到一个错误提示。</p><h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>在属性名前加<code>readonly</code>来指定只读属性。设置只读后，除了对象刚刚创建的时候可以修改值，创建后就不可修改了。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs maxima">interface Person &#123;<br>  <span class="hljs-built_in">readonly</span> name: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-built_in">readonly</span> <span class="hljs-built_in">height</span>?: number;<br>&#125;<br><br><span class="hljs-built_in">let</span> susan: Person = &#123;<br>    name: &#x27;Susan&#x27;,<br>    <span class="hljs-built_in">height</span>: <span class="hljs-number">160</span><br>&#125;<br>susan.<span class="hljs-built_in">height</span> = <span class="hljs-number">170</span>; // <span class="hljs-built_in">error</span>!<br></code></pre></td></tr></table></figure><p>TypeScript 还提供了<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">let <span class="hljs-selector-tag">a</span>: ReadonlyArray&lt;number&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.push</span>(<span class="hljs-number">3</span>); // 类型“readonly number<span class="hljs-selector-attr">[]</span>”上不存在属性“push”。<br></code></pre></td></tr></table></figure><p>readonly vs const</p><ul><li>最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。</li></ul><h2 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h2><p>有时候不确定具体的属性名，可以使用任意属性来定义接口。</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">interface</span> <span class="hljs-type">Person</span> &#123;<br>    name: <span class="hljs-type">string</span>;<br>    age?: number;<br>    [propName: <span class="hljs-type">string</span>]: <span class="hljs-type">any</span>;<br>    // 不想使用<span class="hljs-type">any</span>则可以使用联合类型<br>    // [propName: <span class="hljs-type">string</span>]: <span class="hljs-type">string</span> | number | undefined;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，一旦定义了任意属性，那么确定属性（name: string;）和可选属性（age?: number;）的类型都必须是它的类型的子集。</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。</p><p>为了使用接口表示函数类型，我们需要给接口定义一个个函数外形。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// 接口定义一个函数外形，其中包括参数个数，参数类型，返回值类型。</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SearchFunc</span> </span>&#123;<br>  (source: <span class="hljs-keyword">string</span>, subString: <span class="hljs-keyword">string</span>): <span class="hljs-keyword">boolean</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> mySearch: SearchFunc;<br>mySearch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(source: <span class="hljs-keyword">string</span>, subString: <span class="hljs-keyword">string</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> result = source.search(subString);<br>  <span class="hljs-keyword">return</span> result &gt; <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>与使用接口描述函数类型差不多，我们也可以描述那些能够<code>通过索引得到</code>的类型，比如 a[10] 或 ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">StringArray</span> &#123;<br>  [<span class="hljs-meta">index: number</span>]: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">let</span> myArray: StringArray;<br>myArray = [<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Fred&quot;</span>];<br><br><span class="hljs-keyword">let</span> myStr: <span class="hljs-built_in">string</span> = myArray[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。</span><br></code></pre></td></tr></table></figure><h2 id="使用类实现接口"><a href="#使用类实现接口" class="headerlink" title="使用类实现接口"></a>使用类实现接口</h2><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">interface</span> ClockInterface <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    currentTime: Date;</span><br><span class="hljs-comment">    setTime(d: Date);</span><br><span class="hljs-comment">&#125;</span><br><br><span class="hljs-keyword">class</span> Clock <span class="hljs-keyword">implements</span> ClockInterface <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    currentTime: Date;</span><br><span class="hljs-comment">    setTime(d: Date) &#123;</span><br><span class="hljs-comment">        this.currentTime = d;</span><br><span class="hljs-comment">    &#125;</span><br>    <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(h: number, m: number)</span> <span class="hljs-comment">&#123; &#125;</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h2><p>与类一样，接口也可以相互继承，这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。同时接口也可以继承多个接口。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">interface</span> <span class="hljs-symbol">Shape</span> &#123;<br>    color: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">PenStroke</span> &#123;<br>    penWidth: number;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">Square</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">Shape</span>, <span class="hljs-symbol">PenStroke</span> &#123;<br>    sideLength: number;<br>&#125;<br><br>let square = &lt;Square&gt;&#123;&#125;;<br>square.color = <span class="hljs-string">&quot;blue&quot;</span>;<br>square.sideLength = <span class="hljs-number">10</span>;<br>square.penWidth = <span class="hljs-number">5.0</span>;<br></code></pre></td></tr></table></figure><h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Control</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> state: any;<br>&#125;<br><br>interface <span class="hljs-type">SelectableControl</span> <span class="hljs-keyword">extends</span> <span class="hljs-type">Control</span> &#123;<br>    select(): void;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Control</span> <span class="hljs-title">implements</span> <span class="hljs-title">SelectableControl</span> </span>&#123;<br>    select() &#123; &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Control</span> </span>&#123;<br>    select() &#123; &#125;<br>&#125;<br><br><span class="hljs-comment">// 错误：“Image”类型缺少“state”属性。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Image</span> <span class="hljs-title">implements</span> <span class="hljs-title">SelectableControl</span> </span>&#123;<br>    select() &#123; &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Location</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子里，SelectableControl 包含了 Control 的所有成员，包括私有成员 state。 因为 state 是私有成员，所以只能够是 Control 的子类们才能实现 SelectableControl 接口。 因为只有 Control 的子类才能够拥有一个声明于 Control 的私有成员 state，这对私有成员的兼容性是必需的。</p><p>在 Control 类内部，是允许通过 SelectableControl 的实例来访问私有成员 state 的。 实际上， SelectableControl 接口和拥有 select 方法的 Control 类是一样的。 Button 和 TextBox 类是 SelectableControl 的子类（因为它们都继承自 Control 并有 select 方法），但 Image 和 Location 类并不是这样的。</p><h4 id="示例与内容来自TypeScript-文档"><a href="#示例与内容来自TypeScript-文档" class="headerlink" title="示例与内容来自TypeScript 文档"></a>示例与内容来自<a href="https://www.tslang.cn/docs/handbook/interfaces.html">TypeScript 文档</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS-简介、搭建以及基础类型</title>
    <link href="/article/53dc5db4.html"/>
    <url>/article/53dc5db4.html</url>
    
    <content type="html"><![CDATA[<img src="/article/53dc5db4/banner.jpg" class="" title="image"><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h4 id="什么是-typescript"><a href="#什么是-typescript" class="headerlink" title="什么是 typescript?"></a>什么是 typescript?</h4><p>TypeScript 简称 TS，TS 与 JS 的关系和 Less&#x2F;Sass 与 CSS 的关系有相似之处。<br>Less&#x2F;Sass 是对 CSS 的扩展，最终会转换成 CSS；TS 是对 JS 的扩展，最终会编译成 JS。</p><h4 id="为什么需要-TypeScript"><a href="#为什么需要-TypeScript" class="headerlink" title="为什么需要 TypeScript?"></a>为什么需要 TypeScript?</h4><p>因为 JS 是弱类型，很多错误在运行时才会被发现，TS 有一套静态检测机制，可以在编译时就发现错误。</p><h4 id="TypeScript-特点"><a href="#TypeScript-特点" class="headerlink" title="TypeScript 特点"></a>TypeScript 特点</h4><ul><li>支持最新 JS 的新特性</li><li>支持代码静态检查</li><li>支持后端语言中的特性（枚举、泛型、类型转换、命名空间、声明文件、类、接口等）</li></ul><h2 id="二、搭建-TS-环境"><a href="#二、搭建-TS-环境" class="headerlink" title="二、搭建 TS 环境"></a>二、搭建 TS 环境</h2><h4 id="安装最新版-TS"><a href="#安装最新版-TS" class="headerlink" title="安装最新版 TS"></a>安装最新版 TS</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -g typescript<br></code></pre></td></tr></table></figure><h4 id="安装-ts-node"><a href="#安装-ts-node" class="headerlink" title="安装 ts-node"></a>安装 ts-node</h4><p>安装后可以类似 node 运行 js 文件一样，使用<code>ts-node test.ts</code>来运行编译 ts 文件。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm i -g ts-<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><h2 id="三、基础类型"><a href="#三、基础类型" class="headerlink" title="三、基础类型"></a>三、基础类型</h2><h4 id="布尔值（boolean）"><a href="#布尔值（boolean）" class="headerlink" title="布尔值（boolean）"></a>布尔值（boolean）</h4><p>表示 true&#x2F;false</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h4 id="数字（number）"><a href="#数字（number）" class="headerlink" title="数字（number）"></a>数字（number）</h4><p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">let <span class="hljs-selector-tag">a</span>: number = <span class="hljs-number">9</span>;<br>let <span class="hljs-selector-tag">b</span>: number = <span class="hljs-number">0</span>xf00d;<br></code></pre></td></tr></table></figure><h4 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span><span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> string</span> = <span class="hljs-string">&#x27;whr&#x27;</span>;<br></code></pre></td></tr></table></figure><p>模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ &#96;），并且以${ expr }这种形式嵌入表达式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`whr`</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">24</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">sentence</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123; name &#125;</span>.</span><br><span class="hljs-string">I&#x27;ll be <span class="hljs-subst">$&#123; age + <span class="hljs-number">1</span> &#125;</span> years old next month.`</span>;<br></code></pre></td></tr></table></figure><p>与这句效果相同</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> sentence: string <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, my name is &quot;</span> <span class="hljs-operator">+</span> name <span class="hljs-operator">+</span> <span class="hljs-string">&quot;.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>    <span class="hljs-string">&quot;I&#x27;ll be &quot;</span> <span class="hljs-operator">+</span> (age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">+</span> <span class="hljs-string">&quot; years old next month.&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h4><p>定义数组有两种方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">list1</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// 定义了只有number类型数据的数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">list2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// 使用泛型定义数组</span><br></code></pre></td></tr></table></figure><h4 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h4><p>元组类型允许表示一个<code>已知类型</code>和<code>已知数量</code>的数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>];<br>x = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;str&#x27;</span>]; <span class="hljs-comment">// OK</span><br>x = [<span class="hljs-string">&#x27;str&#x27;</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// Error,数量和类型要一一对应。</span><br></code></pre></td></tr></table></figure><p>访问元素的某个方法时，会根据元素类型判断是否有某个方法。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x[<span class="hljs-number">1</span>].substr(<span class="hljs-number">1</span>)); <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x[<span class="hljs-number">0</span>].substr(<span class="hljs-number">1</span>)); <span class="hljs-comment">// Error,&#x27;number&#x27; does not have &#x27;substr&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h4><p>enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">enum</span> <span class="hljs-variable">Color</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Red</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Green</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Blue</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-variable">let</span> <span class="hljs-variable">c</span><span class="hljs-operator">:</span> <span class="hljs-variable">Color</span> <span class="hljs-operator">=</span> <span class="hljs-variable">Color</span><span class="hljs-operator">.</span><span class="hljs-built_in">Green</span><span class="hljs-operator">;</span> <span class="hljs-operator">//</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以为元素编号</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">enum</span> Color &#123;Red = <span class="hljs-number">1</span>, Green = <span class="hljs-number">2</span>, Blue = <span class="hljs-number">4</span>&#125;<br><span class="hljs-attribute">let</span> c: Color = Color.Green; // c = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以根据编号反向查找相应的名字</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span> = <span class="hljs-number">1</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">colorName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Color</span>[<span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colorName);  <span class="hljs-comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span><br></code></pre></td></tr></table></figure><h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h4><p>有时有些变量并不清楚类型，例如来自用户的输入或第三方代码库，<br>此时如果只想代码通过编译检查，可以使用 any 类型来标记这些变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">5</span>;<br>notSure = <span class="hljs-string">&quot;maybe a string instead&quot;</span>;<br>notSure = <span class="hljs-literal">false</span>; <span class="hljs-comment">// okay, definitely a boolean</span><br></code></pre></td></tr></table></figure><p>在改写代码的时候，any 允许在编译时选择性包含或移除类型检查。</p><h4 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h4><p>void 类型表示没有任何类型，当函数无返回值时，其返回值类型是 void</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-title function_">void</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>声明 void 类型的变量，只能赋予 undefined 和 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable</span>: <span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><h4 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h4><p>默认 Null 和 Undefined 是所有类型的子类型，也就是可以将 null 和 undefined 赋值给其他类型。当指定了–strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们自己。 这能避免很多常见的问题。</p><h4 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h4><p>never 类型表示的是那些永不存在的值的类型。<br>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span><span class="hljs-params">(message: string)</span>: never &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(message);<br>&#125;<br><br><span class="hljs-comment">// 推断的返回值类型为never</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> error(<span class="hljs-string">&quot;Something failed&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span><span class="hljs-params">()</span>: never &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>表示非基本类型，也就是除了 number，string，boolean，symbol，null 或 undefined 之外的类型。</p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>有时如果知道某个变量有比现有类型更确切的类型，可以使用类型断言对变量进行类型定义。</p><p>类型断言有两种形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>; <span class="hljs-comment">// 当中TS中使用JSX时，这种写法会产生冲突。</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>; <span class="hljs-comment">// 更推荐这种写法</span><br></code></pre></td></tr></table></figure><h4 id="示例与内容来自TypeScript-文档"><a href="#示例与内容来自TypeScript-文档" class="headerlink" title="示例与内容来自TypeScript 文档"></a>示例与内容来自<a href="https://www.tslang.cn/docs/handbook/basic-types.html">TypeScript 文档</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-字符串的新增方法</title>
    <link href="/article/4460526d.html"/>
    <url>/article/4460526d.html</url>
    
    <content type="html"><![CDATA[<img src="/article/4460526d/banner.jpg" class="" title="image"><h2 id="一、String-fromCodePoint"><a href="#一、String-fromCodePoint" class="headerlink" title="一、String.fromCodePoint()"></a>一、String.fromCodePoint()</h2><p>ES5 提供 String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于 0xFFFF 的字符。</p><p>ES6 提供了 String.fromCodePoint()方法，可以识别大于 0xFFFF 的字符，弥补了 String.fromCharCode()方法的不足。在作用上，正好与下面的 codePointAt()方法相反。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">String.fromCodePoint(<span class="hljs-number">0</span>x20BB7)<br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;𠮷&quot;</span><br>String.fromCodePoint(<span class="hljs-number">0</span>x78, <span class="hljs-number">0</span>x1f680, <span class="hljs-number">0</span>x79) === <span class="hljs-string">&#x27;x\uD83D\uDE80y&#x27;</span><br><span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure><p>注意，fromCodePoint 方法定义在 String 对象上，而 codePointAt 方法定义在字符串的实例对象上。</p><h2 id="二、String-raw"><a href="#二、String-raw" class="headerlink" title="二、String.raw()"></a>二、String.raw()</h2><p>该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">String.raw`Hi\n<span class="hljs-variable">$&#123;2+3&#125;</span>!`<br><span class="hljs-regexp">//</span> 实际返回 <span class="hljs-string">&quot;Hi\\n5!&quot;</span>，显示的是转义后的结果 <span class="hljs-string">&quot;Hi\n5!&quot;</span><br>String.raw`Hi\u000A!`;<br><span class="hljs-regexp">//</span> 实际返回 <span class="hljs-string">&quot;Hi\\u000A!&quot;</span>，显示的是转义后的结果 <span class="hljs-string">&quot;Hi\u000A!&quot;</span><br></code></pre></td></tr></table></figure><p>String.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p><p>String.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有 raw 属性的对象，且 raw 属性的值应该是一个数组，对应模板字符串解析后的值。</p><p>作为函数，String.raw()的代码实现基本如下。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">String.raw = <span class="hljs-keyword">function</span> <span class="hljs-params">(strings, <span class="hljs-rest_arg">...values</span>)</span> &#123;<br>  let output = <span class="hljs-string">&#x27;&#x27;</span>;<br>  let index;<br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; values.length; index++) &#123;<br>    output += strings.raw[index] + values[index];<br>  &#125;<br>  output += strings.raw[index]<br>  <span class="hljs-keyword">return</span> output;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、实例方法：codePointAt"><a href="#三、实例方法：codePointAt" class="headerlink" title="三、实例方法：codePointAt()"></a>三、实例方法：codePointAt()</h2><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">var s = <span class="hljs-string">&quot;𠮷&quot;</span>; <span class="hljs-regexp">//</span> 码点是<span class="hljs-number">0</span>x20BB7，大于<span class="hljs-number">0</span>xFFFF<br>s.length <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>s.charAt(<span class="hljs-number">0</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;&#x27;</span><br>s.charAt(<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;&#x27;</span><br>s.charCodeAt(<span class="hljs-number">0</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">55362</span><br>s.charCodeAt(<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">57271</span><br></code></pre></td></tr></table></figure><p>ES6 提供了 codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">let s = <span class="hljs-string">&#x27;𠮷a&#x27;</span>;<br>s.codePointAt(<span class="hljs-number">0</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">134071</span><br>s.codePointAt(<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">57271</span><br>s.codePointAt(<span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">97</span><br></code></pre></td></tr></table></figure><p>codePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用 toString()方法转换一下。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> s = &#x27;𠮷a&#x27;;<br>s.code<span class="hljs-constructor">PointAt(0)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(16)</span> <span class="hljs-comment">// &quot;20bb7&quot;</span><br>s.code<span class="hljs-constructor">PointAt(2)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(16)</span> <span class="hljs-comment">// &quot;61&quot;</span><br></code></pre></td></tr></table></figure><p>codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符 a 在字符串 s 的正确位置序号应该是 1，但是必须向 codePointAt()方法传入 2。解决这个问题的一个办法是使用 for…of 循环，因为它会正确识别 32 位的 UTF-16 字符。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> s = &#x27;𠮷a&#x27;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ch <span class="hljs-keyword">of</span> s) &#123;<br>  console.log(ch.code<span class="hljs-constructor">PointAt(0)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(16)</span>);<br>&#125;<br><span class="hljs-comment">// 20bb7</span><br><span class="hljs-comment">// 61</span><br></code></pre></td></tr></table></figure><p>另一种方法也可以，使用扩展运算符（…）进行展开运算。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let arr = [...<span class="hljs-string">&#x27;𠮷a&#x27;</span>]; <span class="hljs-comment">// arr.length === 2</span><br>arr.forEach(<br>  <span class="hljs-function"><span class="hljs-params">ch</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(ch.codePointAt(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>))<br>);<br><span class="hljs-comment">// 20bb7</span><br><span class="hljs-comment">// 61</span><br></code></pre></td></tr></table></figure><h2 id="四、实例方法：normalize"><a href="#四、实例方法：normalize" class="headerlink" title="四、实例方法：normalize()"></a>四、实例方法：normalize()</h2><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如 Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如 O（\u004F）和 ˇ（\u030C）合成 Ǒ（\u004F\u030C）。</p><p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;\u01D1&#x27;</span>===<span class="hljs-string">&#x27;\u004F\u030C&#x27;</span> <span class="hljs-regexp">//</span>false<br><span class="hljs-string">&#x27;\u01D1&#x27;</span>.length <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br><span class="hljs-string">&#x27;\u004F\u030C&#x27;</span>.length <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>ES6 提供字符串实例的 normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-string">&#x27;\u01D1&#x27;</span>.<span class="hljs-keyword">normalize</span>() === <span class="hljs-string">&#x27;\u004F\u030C&#x27;</span>.<span class="hljs-keyword">normalize</span>()<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>normalize 方法可以接受一个参数来指定 normalize 的方式，参数的四个可选值如下。</p><ul><li>NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li><li>NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li><li>NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize 方法不能识别中文。）</li><li>NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li></ul><h2 id="五、实例方法：includes-startsWith-endsWith"><a href="#五、实例方法：includes-startsWith-endsWith" class="headerlink" title="五、实例方法：includes(), startsWith(), endsWith()"></a>五、实例方法：includes(), startsWith(), endsWith()</h2><p>以前 JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><ul><li>includes()：返回布尔值，表示是否找到了参数字符串。</li><li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">let s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>s.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-regexp">//</span> true<br>s.endsWith(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-regexp">//</span> true<br>s.includes(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">let s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br>s.startsWith(<span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-regexp">//</span> true<br>s.endsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">5</span>) <span class="hljs-regexp">//</span> true<br>s.includes(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><p>使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。</p><h2 id="六、实例方法：repeat"><a href="#六、实例方法：repeat" class="headerlink" title="六、实例方法：repeat()"></a>六、实例方法：repeat()</h2><p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;hellohello&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">0</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>参数如果是小数，会被取整。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">2.9</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;nana&quot;</span><br></code></pre></td></tr></table></figure><p>如果 repeat 的参数是负数或者 Infinity，会报错。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-keyword">repeat</span><span class="hljs-comment">(Infinity)</span><br><span class="hljs-comment">// RangeError</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-keyword">repeat</span><span class="hljs-comment">(-1)</span><br><span class="hljs-comment">// RangeError</span><br></code></pre></td></tr></table></figure><p>0 到 1、0 到-1 以及 NaN 等同于 0。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">0.9</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(-<span class="hljs-number">0.9</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(NaN) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>如果 repeat 的参数是字符串，则会先转换成数字。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-string">&#x27;na&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;nanana&quot;</span><br></code></pre></td></tr></table></figure><h2 id="七、实例方法：padStart-，padEnd"><a href="#七、实例方法：padStart-，padEnd" class="headerlink" title="七、实例方法：padStart()，padEnd()"></a>七、实例方法：padStart()，padEnd()</h2><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;x&#x27;</span>.padStart(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;ababx&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padStart(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;abax&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padEnd(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xabab&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padEnd(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xaba&#x27;</span><br></code></pre></td></tr></table></figure><p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;xxx&#x27;</span>.padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br><span class="hljs-string">&#x27;xxx&#x27;</span>.padEnd(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br></code></pre></td></tr></table></figure><p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;abc&#x27;</span>.padStart(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;0123456789&#x27;</span>)<br><span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;0123456abc&#x27;</span><br></code></pre></td></tr></table></figure><p>如果省略第二个参数，默认使用空格补全长度。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;x&#x27;</span>.padStart(<span class="hljs-number">4</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;   x&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padEnd(<span class="hljs-number">4</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;x   &#x27;</span><br></code></pre></td></tr></table></figure><h2 id="八、实例方法：trimStart-，trimEnd"><a href="#八、实例方法：trimStart-，trimEnd" class="headerlink" title="八、实例方法：trimStart()，trimEnd()"></a>八、实例方法：trimStart()，trimEnd()</h2><p>它们的行为与 trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">const s = <span class="hljs-string">&#x27;  abc  &#x27;</span>;<br>s.trim() <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;abc&quot;</span><br>s.trimStart() <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;abc  &quot;</span><br>s.trimEnd() <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;  abc&quot;</span><br></code></pre></td></tr></table></figure><p>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p><p>浏览器还部署了额外的两个方法，trimLeft()是 trimStart()的别名，trimRight()是 trimEnd()的别名。</p><h2 id="九、实例方法：matchAll"><a href="#九、实例方法：matchAll" class="headerlink" title="九、实例方法：matchAll()"></a>九、实例方法：matchAll()</h2><p>matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/string-methods">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-字符串的扩展（下）</title>
    <link href="/article/88443906.html"/>
    <url>/article/88443906.html</url>
    
    <content type="html"><![CDATA[<img src="/article/88443906/banner.jpg" class="" title="image"><h2 id="一、模板字符串"><a href="#一、模板字符串" class="headerlink" title="一、模板字符串"></a>一、模板字符串</h2><p>以前输出模板通常是采用字符串拼接</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-string">&quot;hello world&quot;</span> + <span class="hljs-keyword">name</span><br></code></pre></td></tr></table></figure><p>引入模板字符串后，采用反引号做标识，使用${}包裹变量。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`hello world <span class="hljs-subst">$&#123; name &#125;</span>`</span><br></code></pre></td></tr></table></figure><p>${}大括号内部可以放入任意的 JavaScript 表达式，可以进行运算以及引用对象属性，可以调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// JavaScript 表达式</span><br><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span>;<br><br><span class="hljs-string">`<span class="hljs-subst">$&#123;x&#125;</span> + <span class="hljs-subst">$&#123;y * <span class="hljs-number">2</span>&#125;</span> = <span class="hljs-subst">$&#123;x + y * <span class="hljs-number">2</span>&#125;</span>`</span><br><span class="hljs-comment">// &quot;1 + 4 = 5&quot;</span><br><br><span class="hljs-comment">// 引用对象属性</span><br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-string">`<span class="hljs-subst">$&#123;obj.x + obj.y&#125;</span>`</span><br><span class="hljs-comment">// &quot;3&quot;</span><br><br><span class="hljs-comment">// 调用函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>&#125;<br><span class="hljs-string">`foo <span class="hljs-subst">$&#123;fn()&#125;</span> bar`</span><br><span class="hljs-comment">// foo Hello World bar</span><br></code></pre></td></tr></table></figure><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法。</p><h2 id="二、实例：模板编译"><a href="#二、实例：模板编译" class="headerlink" title="二、实例：模板编译"></a>二、实例：模板编译</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bnf">let template = `<br><span class="hljs-attribute">&lt;ul&gt;</span><br>  <span class="hljs-attribute">&lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span><br>    <span class="hljs-attribute">&lt;li&gt;</span><span class="hljs-attribute">&lt;%= data.supplies[i] %&gt;</span><span class="hljs-attribute">&lt;/li&gt;</span><br>  <span class="hljs-attribute">&lt;% &#125; %&gt;</span><br><span class="hljs-attribute">&lt;/ul&gt;</span><br>`;<br></code></pre></td></tr></table></figure><p>使用正则转换成表达式字符串</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let evalExpr = <span class="hljs-regexp">/&lt;%=(.+?)%&gt;/g</span>;<br>let expr = <span class="hljs-regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;<br>template = template<br>  .<span class="hljs-built_in">replace</span>(evalExpr, <span class="hljs-string">&#x27;`); \n  echo( $1 ); \n  echo(`&#x27;</span>)<br>  .<span class="hljs-built_in">replace</span>(expr, <span class="hljs-string">&#x27;`); \n $1 \n  echo(`&#x27;</span>);<br>template = <span class="hljs-string">&#x27;echo(`&#x27;</span> + template + <span class="hljs-string">&#x27;`);&#x27;</span>;<br></code></pre></td></tr></table></figure><p>然后，将 template 封装在一个函数里面返回，就可以了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">let script =<br>`(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span><span class="hljs-params">(data)</span></span>&#123;<br>  let <span class="hljs-built_in">output</span> = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span><span class="hljs-params">(html)</span></span>&#123;<br>    <span class="hljs-built_in">output</span> += html;<br>  &#125;<br>  $&#123; template &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">output</span>;<br>&#125;)`;<br><span class="hljs-keyword">return</span> script;<br></code></pre></td></tr></table></figure><p>完整 compile 函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> compile(template)&#123;<br>  const evalExpr = /&lt;%=(.+?)%&gt;/g;<br>  const <span class="hljs-built_in">expr</span> = /&lt;%([\s\S]+?)%&gt;/g;<br>  template = template<br>    .replace(evalExpr, <span class="hljs-string">&#x27;`); \n  echo( $1 ); \n  echo(`&#x27;</span>)<br>    .replace(<span class="hljs-built_in">expr</span>, <span class="hljs-string">&#x27;`); \n $1 \n  echo(`&#x27;</span>);<br>  template = <span class="hljs-string">&#x27;echo(`&#x27;</span> + template + <span class="hljs-string">&#x27;`);&#x27;</span>;<br>  <span class="hljs-built_in">let</span> script =<br>  `(<span class="hljs-keyword">function</span> parse(data)&#123;<br>    <span class="hljs-built_in">let</span> output = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-built_in">echo</span>(html)&#123;<br>      output += html;<br>    &#125;<br>    <span class="hljs-variable">$&#123; template &#125;</span><br>    <span class="hljs-built_in">return</span> output;<br>  &#125;)`;<br>  <span class="hljs-built_in">return</span> script;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、标签模板"><a href="#三、标签模板" class="headerlink" title="三、标签模板"></a>三、标签模板</h2><p>紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">alert`hello`<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-title">alert</span><span class="hljs-params">([<span class="hljs-string">&#x27;hello&#x27;</span>])</span></span><br></code></pre></td></tr></table></figure><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span>;<br>tag<span class="hljs-string">`Hello <span class="hljs-subst">$&#123; a + b &#125;</span> world <span class="hljs-subst">$&#123; a * b &#125;</span>`</span>;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-title function_">tag</span>([<span class="hljs-string">&#x27;Hello &#x27;</span>, <span class="hljs-string">&#x27; world &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>], <span class="hljs-number">15</span>, <span class="hljs-number">50</span>);<br></code></pre></td></tr></table></figure><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message =<br>  <span class="hljs-title class_">SaferHTML</span><span class="hljs-string">`&lt;p&gt;<span class="hljs-subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SaferHTML</span>(<span class="hljs-params">templateData</span>) &#123;<br>  <span class="hljs-keyword">let</span> s = templateData[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> arg = <span class="hljs-title class_">String</span>(<span class="hljs-variable language_">arguments</span>[i]);<br>    <span class="hljs-comment">// Escape special characters in the substitution.</span><br>    s += arg.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">&quot;&amp;amp;&quot;</span>)<br>            .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&quot;&amp;lt;&quot;</span>)<br>            .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&quot;&amp;gt;&quot;</span>);<br>    <span class="hljs-comment">// Don&#x27;t escape special characters in the template.</span><br>    s += templateData[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">i18n`Welcome to <span class="hljs-variable">$&#123;siteName&#125;</span>, you are visitor number <span class="hljs-variable">$&#123;visitorNumber&#125;</span>!`<br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;欢迎访问xxx，您是第xxxx位访问者！&quot;</span><br></code></pre></td></tr></table></figure><h2 id="四、模板字符串的限制"><a href="#四、模板字符串的限制" class="headerlink" title="四、模板字符串的限制"></a>四、模板字符串的限制</h2><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p><p>为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回 undefined，而不是报错，并且从 raw 属性上面可以得到原始字符串。</p><p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/string">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-字符串的扩展（上）</title>
    <link href="/article/888cebaf.html"/>
    <url>/article/888cebaf.html</url>
    
    <content type="html"><![CDATA[<img src="/article/888cebaf/banner.jpg" class="" title="image"><h2 id="一、字符的-Unicode-表示法"><a href="#一、字符的-Unicode-表示法" class="headerlink" title="一、字符的 Unicode 表示法"></a>一、字符的 Unicode 表示法</h2><p>ES6 加强了对 Unicode 的支持，允许采用\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;\u0061&quot;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p>但是，这种表示法只限于码点在\u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;\uD842\uDFB7&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;𠮷&quot;</span><br><span class="hljs-string">&quot;\u20BB7&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot; 7&quot;</span> 该段被理解为\u20BB+<span class="hljs-number">7</span>，而\u20BB是不可打印字符，因此以空格显示，其后跟着一个 <span class="hljs-number">7</span>。<br></code></pre></td></tr></table></figure><p>改进后，只需将码点放入大括号中，即可正确解读。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;\u&#123;20BB7&#125;&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;𠮷&quot;</span><br><br><span class="hljs-string">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;ABC&quot;</span><br><br>let hello = <span class="hljs-number">123</span>;<br>hell\u&#123;<span class="hljs-number">6</span>F&#125; <span class="hljs-regexp">//</span> <span class="hljs-number">123</span><br><br><span class="hljs-string">&#x27;\u&#123;1F680&#125;&#x27;</span> === <span class="hljs-string">&#x27;\uD83D\uDE80&#x27;</span><br><span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure><h2 id="二、字符串的遍历器接口"><a href="#二、字符串的遍历器接口" class="headerlink" title="二、字符串的遍历器接口"></a>二、字符串的遍历器接口</h2><p>ES6 为字符串添加了 Iterator 接口，使得字符串可以被 for…of 循环遍历。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span> (let codePoint of <span class="hljs-string">&#x27;foo&#x27;</span>) &#123;<br>  console.log(codePoint)<br>&#125;<br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;f&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;o&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;o&quot;</span><br></code></pre></td></tr></table></figure><p>并且这个遍历器可以识别码点大于 0xFFFF 的码点，原本的 for 循环无法识别。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let <span class="hljs-built_in">text</span> = String.<span class="hljs-built_in">fromCodePoint</span>(<span class="hljs-number">0x20BB7</span>);<br><br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">text</span>.<span class="hljs-built_in">length</span>; i++) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">text</span>[i]);<br>&#125;<br><span class="hljs-comment">// &quot; &quot;</span><br><span class="hljs-comment">// &quot; &quot;</span><br><br><span class="hljs-keyword">for</span> (let i of <span class="hljs-built_in">text</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i);<br>&#125;<br><span class="hljs-comment">// &quot;𠮷&quot;</span><br></code></pre></td></tr></table></figure><h2 id="三、JSON-stringify-的改造"><a href="#三、JSON-stringify-的改造" class="headerlink" title="三、JSON.stringify() 的改造"></a>三、JSON.stringify() 的改造</h2><p>根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的 JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。</p><p>具体来说，UTF-8 标准规定，0xD800 到 0xDFFF 之间的码点，不能单独使用，必须配对使用。比如，\uD834\uDF06 是两个码点，但是必须放在一起配对使用，代表字符 𝌆。这是为了表示码点大于 0xFFFF 的字符的一种变通方法。单独使用\uD834 和\uDFO6 这两个码点是不合法的，或者颠倒顺序也不行，因为\uDF06\uD834 并没有对应的字符。</p><p>JSON.stringify()的问题在于，它可能返回 0xD800 到 0xDFFF 之间的单个码点。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">JSON.stringify(<span class="hljs-string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;\u&#123;D834&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>为了确保返回的是合法的 UTF-8 字符，ES2019 改变了 JSON.stringify()的行为。如果遇到 0xD800 到 0xDFFF 之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">JSON.stringify(<span class="hljs-string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span>\\uD834<span class="hljs-string">&quot;&quot;</span><br>JSON.stringify(<span class="hljs-string">&#x27;\uDF06\uD834&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span>\\udf06\\ud834<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/string">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20220717-孙文西路文化旅游步行街</title>
    <link href="/article/7e908282.html"/>
    <url>/article/7e908282.html</url>
    
    <content type="html"><![CDATA[<img src="/article/7e908282/banner.jpg" class="" title="image"><p><strong><em>应届毕业后来到中山工作，初到中山到今天已经有一个月，从开始工作到今天也已经三周有余。每天除了坐在电脑前码代码，就没有别的活动了，并且因为是单休，工作六天后也很难提起劲到处走走。今天心情好，随手在某度地图搜了一下周边，就锁定了孙文西路文化旅游步行街。顺手拍了几张照片，浅浅修了一下。</em></strong></p><h2 id="1、恩豪大酒店"><a href="#1、恩豪大酒店" class="headerlink" title="1、恩豪大酒店"></a>1、恩豪大酒店</h2><img src="/article/7e908282/hotel.jpg" class="" title="image"><h2 id="2、步行街一角"><a href="#2、步行街一角" class="headerlink" title="2、步行街一角"></a>2、步行街一角</h2><img src="/article/7e908282/WalkingStreet1.jpg" class="" title="image"><img src="/article/7e908282/WalkingStreet2.jpg" class="" title="image"><h2 id="3、烟墩山塔"><a href="#3、烟墩山塔" class="headerlink" title="3、烟墩山塔"></a>3、烟墩山塔</h2><img src="/article/7e908282/tower.jpg" class="" title="image">]]></content>
    
    
    <categories>
      
      <category>Relax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>relax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-其他的解构以及解构赋值的用途</title>
    <link href="/article/ae9359db.html"/>
    <url>/article/ae9359db.html</url>
    
    <content type="html"><![CDATA[<img src="/article/ae9359db/banner.jpg" class="" title="image"><h2 id="一、数值和布尔值的解构赋值"><a href="#一、数值和布尔值的解构赋值" class="headerlink" title="一、数值和布尔值的解构赋值"></a>一、数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> &#123;<span class="hljs-built_in">toString</span>: s&#125; = <span class="hljs-number">123</span>;<br><span class="hljs-attr">s</span> === Number.prototype.<span class="hljs-built_in">toString</span> // <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-built_in">toString</span>: s&#125; = <span class="hljs-literal">true</span>;<br><span class="hljs-attr">s</span> === Boolean.prototype.<span class="hljs-built_in">toString</span> // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">prop</span>: x &#125; = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// TypeError</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">prop</span>: y &#125; = <span class="hljs-literal">null</span>; <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><h2 id="二、函数参数的解构赋值"><a href="#二、函数参数的解构赋值" class="headerlink" title="二、函数参数的解构赋值"></a>二、函数参数的解构赋值</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>([x, y])&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">x</span> + y;<br>&#125;<br>add([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]); // <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>函数 add 的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量 x 和 y。对于函数内部的代码来说，它们能感受到的参数就是 x 和 y。</p><p><strong><em>函数参数的解构也可以使用默认值。</em></strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">function move(&#123;x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>&#125; = &#123;&#125;) &#123;<br>  return <span class="hljs-selector-attr">[x, y]</span>;<br>&#125;<br>move(&#123;x: <span class="hljs-number">3</span>, y: <span class="hljs-number">8</span>&#125;); <span class="hljs-comment">// [3, 8]</span><br>move(&#123;x: <span class="hljs-number">3</span>&#125;); <span class="hljs-comment">// [3, 0]</span><br>move(&#123;&#125;); <span class="hljs-comment">// [0, 0]</span><br>move(); <span class="hljs-comment">// [0, 0]</span><br></code></pre></td></tr></table></figure><p>注意区别，下面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">function move(&#123;x, y&#125; = &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;) &#123;<br>  return <span class="hljs-selector-attr">[x, y]</span>;<br>&#125;<br>move(&#123;x: <span class="hljs-number">3</span>, y: <span class="hljs-number">8</span>&#125;); <span class="hljs-comment">// [3, 8]</span><br>move(&#123;x: <span class="hljs-number">3</span>&#125;); <span class="hljs-comment">// [3, undefined]</span><br>move(&#123;&#125;); <span class="hljs-comment">// [undefined, undefined]</span><br>move(); <span class="hljs-comment">// [0, 0]</span><br></code></pre></td></tr></table></figure><h2 id="三、圆括号问题"><a href="#三、圆括号问题" class="headerlink" title="三、圆括号问题"></a>三、圆括号问题</h2><p>对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。<br>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><p>以下三种解构赋值不得使用圆括号。<br>（1）变量声明语句</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">全部报错</span><br><span class="hljs-string">let</span> [<span class="hljs-string">(a)</span>] <span class="hljs-string">=</span> [<span class="hljs-number">1</span>]<span class="hljs-string">;</span><br><span class="hljs-string">let</span> &#123; <span class="hljs-attr">o:</span> <span class="hljs-string">(</span>&#123; <span class="hljs-attr">p:</span> <span class="hljs-string">p</span> &#125;<span class="hljs-string">)</span> &#125; <span class="hljs-string">=</span> &#123; <span class="hljs-attr">o:</span> &#123; <span class="hljs-attr">p:</span> <span class="hljs-number">2</span> &#125; &#125;<span class="hljs-string">;</span><br></code></pre></td></tr></table></figure><p>（2）函数参数<br>函数参数也属于变量声明，因此不能带有圆括号</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">// 报错<br><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>([(z)]) &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">z</span>; &#125;<br>// 报错<br><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>([z,(x)]) &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">x</span>; &#125;<br></code></pre></td></tr></table></figure><p>（3）赋值语句的模式</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">// 全部报错</span><br><span class="hljs-comment">(&#123; p: a &#125;)</span> = &#123; p: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-comment">([a])</span> = [<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">[(b)] = [<span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> 正确<br>(&#123; p: (d) &#125; = &#123;&#125;); <span class="hljs-regexp">//</span> 正确<br>[(parseInt.prop)] = [<span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> 正确<br></code></pre></td></tr></table></figure><h2 id="四、用途"><a href="#四、用途" class="headerlink" title="四、用途"></a>四、用途</h2><p>（1）交换变量的值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span>;<br>[<span class="hljs-meta">x, y</span>] = [y, x];<br></code></pre></td></tr></table></figure><p>（2）从函数返回多个值</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ada">// 返回一个数组<br><span class="hljs-keyword">function</span> <span class="hljs-title">example</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">[1,</span> <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br>let [a, b, c] = example();<br><br>// 返回一个对象<br><span class="hljs-keyword">function</span> <span class="hljs-title">example</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    foo: <span class="hljs-number">1</span>,<br>    bar: <span class="hljs-number">2</span><br>  &#125;;<br>&#125;<br>let &#123; foo, bar &#125; = example();<br></code></pre></td></tr></table></figure><p>（3）函数参数的定义<br>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 参数是一组有次序的值</span><br>function <span class="hljs-built_in">f</span>([x, y, z]) &#123; ... &#125;<br><span class="hljs-built_in">f</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 参数是一组无次序的值</span><br>function <span class="hljs-built_in">f</span>(&#123;x, y, z&#125;) &#123; ... &#125;<br><span class="hljs-built_in">f</span>(&#123;z: <span class="hljs-number">3</span>, y: <span class="hljs-number">2</span>, x: <span class="hljs-number">1</span>&#125;);<br></code></pre></td></tr></table></figure><p>（4）提取 JSON 数据</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> jsonData = &#123;<br> <span class="hljs-built_in"> id</span>: <span class="hljs-number">42</span>,<br>  status: <span class="hljs-string">&quot;OK&quot;</span>,<br>  data: [<span class="hljs-number">867</span>, <span class="hljs-number">5309</span>]<br>&#125;;<br><span class="hljs-keyword">let</span> &#123;<span class="hljs-built_in"> id</span>, status, data:<span class="hljs-built_in"> number</span> &#125; = jsonData;<br>console.log<span class="hljs-built_in">(id</span>, status,<span class="hljs-built_in"> number</span>);<br>// <span class="hljs-number">42</span>, <span class="hljs-string">&quot;OK&quot;</span>, [<span class="hljs-number">867</span>, <span class="hljs-number">5309</span>]<br></code></pre></td></tr></table></figure><p>（5）函数参数的默认值<br>指定参数的默认值，就避免了在函数体内部再写 var foo &#x3D; config.foo || ‘default foo’;这样的语句。</p><p>（6）遍历 Map 结构<br>任何部署了 Iterator 接口的对象，都可以用 for…of 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">const <span class="hljs-built_in">map</span> = <span class="hljs-built_in">new</span> Map();<br><span class="hljs-built_in">map</span>.set(&#x27;<span class="hljs-built_in">first</span>&#x27;, &#x27;hello&#x27;);<br><span class="hljs-built_in">map</span>.set(&#x27;<span class="hljs-built_in">second</span>&#x27;, &#x27;world&#x27;);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> [<span class="hljs-built_in">key</span>, value] of <span class="hljs-built_in">map</span>) &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">key</span> + <span class="hljs-string">&quot; is &quot;</span> + value);<br>&#125;<br>// <span class="hljs-built_in">first</span> <span class="hljs-built_in">is</span> hello<br>// <span class="hljs-built_in">second</span> <span class="hljs-built_in">is</span> world<br></code></pre></td></tr></table></figure><p>（7）输入模块的指定方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">SourceMapConsumer</span>, <span class="hljs-title class_">SourceNode</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;source-map&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/destructuring">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识RxJS与demo实践</title>
    <link href="/article/222d0cce.html"/>
    <url>/article/222d0cce.html</url>
    
    <content type="html"><![CDATA[<img src="/article/222d0cce/banner.jpg" class="" title="新兰永恒 image"><h2 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h2><blockquote><p>RxJS 中 Stream 的概念：将不断产生的数据或事件组成序列称作 Stream。</p></blockquote><p>1.Observable：被观察的对象，代表未来可能产生的数据或事件的集合。</p><p>2.Observer：观察者，通常是回调函数，用来接收观察结果。其中包括三个属性（next，complete、error）。</p><p>3.Subscription：订阅对象，用于建立 Observer 与 Observable 的联系（也可以取消订阅）。</p><p>4.operators：运算符，对 Observable 产生的数据或事件进行处理的纯函数。常见的运算符有 map、filter、delay 等。</p><p>5.Subject：主体，如同 EventEmitter，用于将 Observable 广播给多个 Observer。在这种情况下，Subject 即是 Observer 又是 Observable。</p><img src="/article/222d0cce/subject%E5%B9%BF%E6%92%AD%E5%9B%BE.jpg" class="" title="Subject广播关系图 image"><h2 id="二、第一个示例"><a href="#二、第一个示例" class="headerlink" title="二、第一个示例"></a>二、第一个示例</h2><p>通常，原生 js 采用如下方式注册事件监听。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">document.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;Clicked!&#x27;</span>));<br></code></pre></td></tr></table></figure><p>使用 RxJS 可以创建 Observable。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> &#123; fromEvent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><br>fromEvent(document, <span class="hljs-string">&#x27;click&#x27;</span>).subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;Clicked!&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="三、Demo"><a href="#三、Demo" class="headerlink" title="三、Demo"></a>三、Demo</h2><h4 id="1-安装-RxJS"><a href="#1-安装-RxJS" class="headerlink" title="1.安装 RxJS"></a>1.安装 RxJS</h4><p>因为只是跑简单示例，所以并没有用构建工具初始化项目。创建 HTML 文件，采用 CDN 引入的方式使用 RxJS。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const &#123; &#125; <span class="hljs-operator">=</span> rxjs<span class="hljs-comment">; // 使用ES6解构赋值按需引入</span><br>const &#123; &#125; <span class="hljs-operator">=</span> rxjs.operators<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果构建项目，则需要使用 <strong>npm install rxjs</strong>来安装 RxJS。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>; <span class="hljs-comment">// 采用import语法引入</span><br><span class="hljs-keyword">import</span> &#123; &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="2-例子一：监听点击事件并输出前三次的数据。"><a href="#2-例子一：监听点击事件并输出前三次的数据。" class="headerlink" title="2.例子一：监听点击事件并输出前三次的数据。"></a>2.例子一：监听点击事件并输出前三次的数据。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; fromEvent &#125; = rxjs;<br><span class="hljs-keyword">const</span> &#123; take &#125;  = rxjs.<span class="hljs-property">operators</span>;<br><br><span class="hljs-keyword">let</span> btnDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.btn&quot;</span>);<br><span class="hljs-title function_">fromEvent</span>(btnDom, <span class="hljs-string">&#x27;click&#x27;</span>).<span class="hljs-title function_">pipe</span>(<br>    <span class="hljs-title function_">take</span>(<span class="hljs-number">3</span>)<br>).<span class="hljs-title function_">subscribe</span>(<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span><br>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    其中fromEvent(btnDom, &#x27;click&#x27;) 为 Observable；</span><br><span class="hljs-comment">    take(3) 为 Operators；</span><br><span class="hljs-comment">    console.log 为 Observer</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="3-例子二：点击按钮延时三秒输出结果。"><a href="#3-例子二：点击按钮延时三秒输出结果。" class="headerlink" title="3.例子二：点击按钮延时三秒输出结果。"></a>3.例子二：点击按钮延时三秒输出结果。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; fromEvent &#125; = rxjs;<br><span class="hljs-keyword">const</span> &#123; take, delay &#125; = rxjs.<span class="hljs-property">operators</span>;<br><br><span class="hljs-keyword">let</span> btnDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.btn&quot;</span>);<br><span class="hljs-title function_">fromEvent</span>(btnDom, <span class="hljs-string">&#x27;click&#x27;</span>).<span class="hljs-title function_">pipe</span>(<br>    <span class="hljs-title function_">delay</span>(<span class="hljs-number">3000</span>),<br>    <span class="hljs-title function_">take</span>(<span class="hljs-number">3</span>)<br>).<span class="hljs-title function_">subscribe</span>(<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击按钮后延时三秒输出&quot;</span>);<br>    &#125;<br>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    其中fromEvent(btnDom, &#x27;click&#x27;) 为 Observable；</span><br><span class="hljs-comment">    delay(3000), take(3) 为 Operators；</span><br><span class="hljs-comment">    () =&gt; &#123;</span><br><span class="hljs-comment">        console.log(&quot;点击按钮后延时三秒输出&quot;);</span><br><span class="hljs-comment">    &#125; 为 Observer</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="部分内容来自RxJS-官方文档"><a href="#部分内容来自RxJS-官方文档" class="headerlink" title="部分内容来自RxJS 官方文档"></a>部分内容来自<a href="https://rxjs.dev/">RxJS 官方文档</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>RxJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-解构赋值之对象</title>
    <link href="/article/51fe8215.html"/>
    <url>/article/51fe8215.html</url>
    
    <content type="html"><![CDATA[<img src="/article/51fe8215/banner.jpg" class="" title="image"><h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">let &#123; foo, bar &#125; = &#123; foo: <span class="hljs-string">&#x27;aaa&#x27;</span>, bar: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>foo <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;aaa&quot;</span><br>bar <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;bbb&quot;</span><br></code></pre></td></tr></table></figure><p><strong><em>（1）对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</em></strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">let &#123; baz &#125; = &#123; foo: <span class="hljs-string">&#x27;aaa&#x27;</span>, bar: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>baz <span class="hljs-regexp">//</span> undefined<br></code></pre></td></tr></table></figure><p>（2）对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 例一</span><br>let &#123; <span class="hljs-built_in">log</span>, <span class="hljs-built_in">sin</span>, <span class="hljs-built_in">cos</span> &#125; = Math;<br><br><span class="hljs-comment">// 例二</span><br>const &#123; <span class="hljs-built_in">log</span> &#125; = <span class="hljs-built_in">console</span>;<br><span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">// hello</span><br>~~~<br></code></pre></td></tr></table></figure><p>（3） 如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">let &#123; foo: baz &#125; = &#123; foo: <span class="hljs-string">&#x27;aaa&#x27;</span>, bar: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>baz <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;aaa&quot;</span><br><br>let obj = &#123; first: <span class="hljs-string">&#x27;hello&#x27;</span>, last: <span class="hljs-string">&#x27;world&#x27;</span> &#125;;<br>let &#123; first: f, last: l &#125; = obj;<br>f <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;hello&#x27;</span><br>l <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;world&#x27;</span><br></code></pre></td></tr></table></figure><p>这实际上说明，对象的解构赋值是下面形式的简写</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">let</span> &#123; foo: foo, <span class="hljs-built_in">bar</span>: <span class="hljs-built_in">bar</span> &#125; = &#123; foo: &#x27;aaa&#x27;, <span class="hljs-built_in">bar</span>: &#x27;bbb&#x27; &#125;;<br></code></pre></td></tr></table></figure><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">let &#123; foo: baz &#125; = &#123; foo: <span class="hljs-string">&#x27;aaa&#x27;</span>, bar: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>baz <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;aaa&quot;</span><br>foo <span class="hljs-regexp">//</span> error: foo is not defined<br></code></pre></td></tr></table></figure><h2 id="二、默认值"><a href="#二、默认值" class="headerlink" title="二、默认值"></a>二、默认值</h2><p>生效条件是对象的属性值严格等于 undefined</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">var &#123;x = <span class="hljs-number">3</span>&#125; = &#123;&#125;;<br>x <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>var &#123;x, y = <span class="hljs-number">5</span>&#125; = &#123;x: <span class="hljs-number">1</span>&#125;;<br>x <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>y <span class="hljs-regexp">//</span> <span class="hljs-number">5</span><br><br>var &#123;x: y = <span class="hljs-number">3</span>&#125; = &#123;&#125;;<br>y <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>var &#123;x: y = <span class="hljs-number">3</span>&#125; = &#123;x: <span class="hljs-number">5</span>&#125;;<br>y <span class="hljs-regexp">//</span> <span class="hljs-number">5</span><br><br>var &#123; message: msg = <span class="hljs-string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;<br>msg <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Something went wrong&quot;</span><br></code></pre></td></tr></table></figure><h2 id="三、注意"><a href="#三、注意" class="headerlink" title="三、注意"></a>三、注意</h2><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">let</span> &#123;<span class="hljs-number">0</span> : <span class="hljs-built_in">first</span>, [arr.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>] : <span class="hljs-built_in">last</span>&#125; = arr;<br><span class="hljs-built_in">first</span> // <span class="hljs-number">1</span><br><span class="hljs-built_in">last</span> // <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/destructuring">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-解构赋值之数组</title>
    <link href="/article/fb4464e6.html"/>
    <url>/article/fb4464e6.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><p>（1）ES6 可以从数组中提取值，按照对应位置，对变量赋值。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">let <span class="hljs-comment">[a, b, c]</span> = <span class="hljs-comment">[1, 2, 3]</span>;<br></code></pre></td></tr></table></figure><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。<br>其他的解构例子如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">let [foo, [[bar], baz]] = [<span class="hljs-number">1</span>, [[<span class="hljs-number">2</span>], <span class="hljs-number">3</span>]];<br>foo <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>bar <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>baz <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>let [ , , third] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>third <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>let [head, ...tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>head <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>tail <span class="hljs-regexp">//</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>（2）如果解构不成功，变量的值就等于 undefined。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">let <span class="hljs-comment">[foo]</span> = <span class="hljs-comment">[]</span>;<br>let <span class="hljs-comment">[bar, foo]</span> = <span class="hljs-comment">[1]</span>;<br></code></pre></td></tr></table></figure><p>（3）另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">let [x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>x <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>y <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>let [a, [b], d] = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>];<br>a <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>b <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>d <span class="hljs-regexp">//</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>（4）如果等号的右边不是数组（或者说不是可遍历的结构），那么将会报错。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 报错<br>let [foo] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> false<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> NaN<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> undefined<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。<br>（5）Set 结构可以解构赋值，实际上，只要某种数据结构具有 Iterator 接口，就可以采用数组形式的解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [x, y, z] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]);<br>x <span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></td></tr></table></figure><h2 id="二、默认值"><a href="#二、默认值" class="headerlink" title="二、默认值"></a>二、默认值</h2><p>（1）解构赋值允许指定默认值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">let [foo = true] = [];<br>foo <span class="hljs-regexp">//</span> true<br><br>let [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-regexp">//</span> x=<span class="hljs-string">&#x27;a&#x27;</span>, y=<span class="hljs-string">&#x27;b&#x27;</span><br>let [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>, undefined]; <span class="hljs-regexp">//</span> x=<span class="hljs-string">&#x27;a&#x27;</span>, y=<span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>注意：只有当数组成员严格等于 undefined，默认值才会生效，使用严格相等运算符（&#x3D;&#x3D;&#x3D;）来判断是否 undefined。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>] <span class="hljs-operator">=</span> [undefined]<span class="hljs-comment">;</span><br><span class="hljs-keyword">x</span> // <span class="hljs-number">1</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>] <span class="hljs-operator">=</span> [<span class="hljs-keyword">null</span>]<span class="hljs-comment">;</span><br><span class="hljs-keyword">x</span> // <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span>不严格等于undefined<br></code></pre></td></tr></table></figure><p>（2）如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> [x = <span class="hljs-title function_">f</span>()] = [<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// 等价于如下代码</span><br><br><span class="hljs-keyword">let</span> x;<br><span class="hljs-keyword">if</span> ([<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>) &#123;<br>  x = <span class="hljs-title function_">f</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  x = [<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）默认值可以引用解构赋值的其他变量，但必须已经声明。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> []<span class="hljs-comment">;     // x=1; y=1</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">2</span>]<span class="hljs-comment">;    // x=2; y=2</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span>]<span class="hljs-comment">; // x=1; y=2</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> y<span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-number">1</span>] <span class="hljs-operator">=</span> []<span class="hljs-comment">;     // ReferenceError: y is not defined</span><br></code></pre></td></tr></table></figure><h2 id="三、特殊的"><a href="#三、特殊的" class="headerlink" title="三、特殊的"></a>三、特殊的</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">const [a, b, c, d, e] = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>a <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;h&quot;</span><br>b <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;e&quot;</span><br>c <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;l&quot;</span><br>d <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;l&quot;</span><br>e <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;o&quot;</span><br></code></pre></td></tr></table></figure><p>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">let &#123;length : <span class="hljs-built_in">len</span>&#125; = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-built_in">len</span> <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/destructuring">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-let和const（下）</title>
    <link href="/article/a5594629.html"/>
    <url>/article/a5594629.html</url>
    
    <content type="html"><![CDATA[<img src="/article/a5594629/banner.png" class="" title="image"><h2 id="一、const-基本用法"><a href="#一、const-基本用法" class="headerlink" title="一、const 基本用法"></a>一、const 基本用法</h2><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-literal">PI</span> = <span class="hljs-number">3.1415</span>;<br><span class="hljs-literal">PI</span> <span class="hljs-comment">// 3.1415</span><br><span class="hljs-literal">PI</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// TypeError: Assignment to constant variable.</span><br></code></pre></td></tr></table></figure><p>const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> foo; <span class="hljs-comment">// SyntaxError: Missing initializer in const declaration</span><br></code></pre></td></tr></table></figure><p>const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。const 声明的常量，也与 let 一样不可重复声明。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  const <span class="hljs-built_in">MAX</span> = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-built_in">MAX</span> <span class="hljs-comment">// Uncaught ReferenceError: MAX is not defined</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">MAX</span>); <span class="hljs-comment">// ReferenceError</span><br>  const <span class="hljs-built_in">MAX</span> = <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hello!&quot;</span>;<br>let age = <span class="hljs-number">25</span>;<br><span class="hljs-comment">// 以下两行都会报错</span><br>const message = <span class="hljs-string">&quot;Goodbye!&quot;</span>;<br>const age = <span class="hljs-number">30</span>;<br>~~~<br></code></pre></td></tr></table></figure><h2 id="二、本质"><a href="#二、本质" class="headerlink" title="二、本质"></a>二、本质</h2><p>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p><p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><p>简言之,const 保证简单类型数据变量指向的内存地址的数据不变,保证复杂类型数据所指向的内存地址中的地址不变,而数据结构是否变化则不能保证.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">const foo = &#123;&#125;;<br><span class="hljs-regexp">//</span> 为 foo 添加一个属性，可以成功<br>foo.prop = <span class="hljs-number">123</span>;<br>foo.prop <span class="hljs-regexp">//</span> <span class="hljs-number">123</span><br><span class="hljs-regexp">//</span> 将 foo 指向另一个对象，就会报错<br>foo = &#123;&#125;; <span class="hljs-regexp">//</span> TypeError: <span class="hljs-string">&quot;foo&quot;</span> is read-only<br></code></pre></td></tr></table></figure><h2 id="三、ES6-声明变量的六种方法"><a href="#三、ES6-声明变量的六种方法" class="headerlink" title="三、ES6 声明变量的六种方法"></a>三、ES6 声明变量的六种方法</h2><p>ES5: var 和 function<br>ES6: var function let const import class</p><h2 id="四、顶层对象"><a href="#四、顶层对象" class="headerlink" title="四、顶层对象"></a>四、顶层对象</h2><p>顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p><p>(1) 没法在编译时就报出变量未声明的错误，只有运行时才能知道<br>(2) 容易不知不觉地就创建了全局变量<br>(3) 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。<br>(4) window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = <span class="hljs-number">1</span>;<br><span class="hljs-regexp">//</span> 如果在 Node 的 REPL 环境，可以写成 global.a<br><span class="hljs-regexp">//</span> 或者采用通用方法，写成 this.a<br>window.a <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>let b = <span class="hljs-number">1</span>;<br>window.b <span class="hljs-regexp">//</span> undefined<br></code></pre></td></tr></table></figure><h4 id="五、globalThis-对象"><a href="#五、globalThis-对象" class="headerlink" title="五、globalThis 对象"></a>五、globalThis 对象</h4><p>(1) 顶层对象在各种实现里面是不统一的。</p><p>浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window。<br>浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self。<br>Node 里面，顶层对象是 global，但其他环境都不支持。</p><p>(2) 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 this 变量，但是有局限性。</p><p>全局环境中，this 会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。<br>函数里面的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this 会指向顶层对象。但是，严格模式下，这时 this 会返回 undefined。<br>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么 eval、new Function 这些方法都可能无法使用。</p><p>ES2020 在语言标准的层面，引入 globalThis 作为顶层对象。也就是说，任何环境下，globalThis 都是存在的，都可以从它拿到顶层对象，指向全局环境下的 this。</p><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/let">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-let和const（上）</title>
    <link href="/article/1de5214c.html"/>
    <url>/article/1de5214c.html</url>
    
    <content type="html"><![CDATA[<img src="/article/1de5214c/banner.jpg" class="" title="image"><h1 id="let-关键字与-const-关键字"><a href="#let-关键字与-const-关键字" class="headerlink" title="let 关键字与 const 关键字"></a>let 关键字与 const 关键字</h1><p>let 关键字和 const 关键字是 ES6 新增的用于变量定义的新特性</p><h2 id="一、-let-声明的变量只在块级作用域有效"><a href="#一、-let-声明的变量只在块级作用域有效" class="headerlink" title="一、 let 声明的变量只在块级作用域有效"></a>一、 let 声明的变量只在块级作用域有效</h2><p>块级作用域大概可以理解为一对花括号{}内</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&#123;<br>  let a1 = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> b1 = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;a1&quot;</span> + a1); <span class="hljs-comment">// ReferenceError: a is not defined.</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;b1&quot;</span> + b1); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="let-适用于-for-循环中的变量定义"><a href="#let-适用于-for-循环中的变量定义" class="headerlink" title="let 适用于 for 循环中的变量定义"></a>let 适用于 for 循环中的变量定义</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i); <span class="hljs-comment">// ReferenceError: i is not defined</span><br></code></pre></td></tr></table></figure><h4 id="let-与-var-区别"><a href="#let-与-var-区别" class="headerlink" title="let 与 var 区别"></a>let 与 var 区别</h4><p>let 作用于块级，而 var 作用于全局，经过 for 循环，let 声明的 i 会取得 6，var 声明的 i 会取得全局的 10</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>for (var i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++) &#123;</span><br>  a[i] <span class="hljs-operator">=</span> function () &#123;<br>    console.log(i)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>&#125;<br>a[<span class="hljs-number">6</span>]()<span class="hljs-comment">; // 10</span><br><br>var a <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>for (let i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++) &#123;</span><br>  a[i] <span class="hljs-operator">=</span> function () &#123;<br>    console.log(i)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>&#125;<br>a[<span class="hljs-number">6</span>]()<span class="hljs-comment">; // 6</span><br></code></pre></td></tr></table></figure><h2 id="二、let-不存在变量提升"><a href="#二、let-不存在变量提升" class="headerlink" title="二、let 不存在变量提升"></a>二、let 不存在变量提升</h2><p>var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined。let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// var 的情况</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo); <span class="hljs-comment">// 输出undefined</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// let 的情况</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(bar); <span class="hljs-comment">// 报错ReferenceError</span><br>let bar = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h2 id="三、暂时性死区（temporal-dead-zone，简称-TDZ）"><a href="#三、暂时性死区（temporal-dead-zone，简称-TDZ）" class="headerlink" title="三、暂时性死区（temporal dead zone，简称 TDZ）"></a>三、暂时性死区（temporal dead zone，简称 TDZ）</h2><p>只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span><br>  <span class="hljs-keyword">let</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-comment">// TDZ开始</span><br>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp); <span class="hljs-comment">// ReferenceError</span><br>  let tmp; <span class="hljs-comment">// TDZ结束</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp); <span class="hljs-comment">// undefined</span><br>  tmp = <span class="hljs-number">123</span>;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp); <span class="hljs-comment">// 123</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样的设计是为了养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><h2 id="四、不允许重复声明"><a href="#四、不允许重复声明" class="headerlink" title="四、不允许重复声明"></a>四、不允许重复声明</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 报错</span><br><span class="hljs-function">function <span class="hljs-title">func</span>()</span> &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 报错</span><br><span class="hljs-function">function <span class="hljs-title">func</span>()</span> &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不能在函数内部重新声明参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> <span class="hljs-keyword">func</span>(arg) &#123;<br>  let arg;<br>&#125;<br><span class="hljs-keyword">func</span>() <span class="hljs-regexp">//</span> 报错<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">func</span>(arg) &#123;<br>  &#123;<br>    let arg;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">func</span>() <span class="hljs-regexp">//</span> 不报错<br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/let">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
