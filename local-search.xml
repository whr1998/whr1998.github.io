<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TS-简介、搭建以及基础类型</title>
    <link href="/article/53dc5db4.html"/>
    <url>/article/53dc5db4.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><h4 id="什么是-typescript"><a href="#什么是-typescript" class="headerlink" title="什么是 typescript?"></a>什么是 typescript?</h4><p>TypeScript 简称 TS，TS 与 JS 的关系和 Less&#x2F;Sass 与 CSS 的关系有相似之处。<br>Less&#x2F;Sass 是对 CSS 的扩展，最终会转换成 CSS；TS 是对 JS 的扩展，最终会编译成 JS。</p><h4 id="为什么需要-TypeScript"><a href="#为什么需要-TypeScript" class="headerlink" title="为什么需要 TypeScript?"></a>为什么需要 TypeScript?</h4><p>因为 JS 是弱类型，很多错误在运行时才会被发现，TS 有一套静态检测机制，可以在编译时就发现错误。</p><h4 id="TypeScript-特点"><a href="#TypeScript-特点" class="headerlink" title="TypeScript 特点"></a>TypeScript 特点</h4><ul><li>支持最新 JS 的新特性</li><li>支持代码静态检查</li><li>支持后端语言中的特性（枚举、泛型、类型转换、命名空间、声明文件、类、接口等）</li></ul><h2 id="二、搭建-TS-环境"><a href="#二、搭建-TS-环境" class="headerlink" title="二、搭建 TS 环境"></a>二、搭建 TS 环境</h2><h4 id="安装最新版-TS"><a href="#安装最新版-TS" class="headerlink" title="安装最新版 TS"></a>安装最新版 TS</h4><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -g typescript<br></code></pre></td></tr></table></figure><h4 id="安装-ts-node"><a href="#安装-ts-node" class="headerlink" title="安装 ts-node"></a>安装 ts-node</h4><p>安装后可以类似 node 运行 js 文件一样，使用<code>ts-node test.ts</code>来运行编译 ts 文件。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">npm i -g ts-<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><h2 id="三、基础类型"><a href="#三、基础类型" class="headerlink" title="三、基础类型"></a>三、基础类型</h2><h4 id="布尔值（boolean）"><a href="#布尔值（boolean）" class="headerlink" title="布尔值（boolean）"></a>布尔值（boolean）</h4><p>表示 true&#x2F;false</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">let</span> isDone: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h4 id="数字（number）"><a href="#数字（number）" class="headerlink" title="数字（number）"></a>数字（number）</h4><p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">let <span class="hljs-selector-tag">a</span>: number = <span class="hljs-number">9</span>;<br>let <span class="hljs-selector-tag">b</span>: number = <span class="hljs-number">0</span>xf00d;<br></code></pre></td></tr></table></figure><h4 id="字符串（string）"><a href="#字符串（string）" class="headerlink" title="字符串（string）"></a>字符串（string）</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span><span class="hljs-built_in"> name</span>:<span class="hljs-built_in"> string</span> = <span class="hljs-string">&#x27;whr&#x27;</span>;<br></code></pre></td></tr></table></figure><p>模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ &#96;），并且以${ expr }这种形式嵌入表达式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`whr`</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">24</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">sentence</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123; name &#125;</span>.</span><br><span class="hljs-string">I&#x27;ll be <span class="hljs-subst">$&#123; age + <span class="hljs-number">1</span> &#125;</span> years old next month.`</span>;<br></code></pre></td></tr></table></figure><p>与这句效果相同</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> sentence: string <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, my name is &quot;</span> <span class="hljs-operator">+</span> name <span class="hljs-operator">+</span> <span class="hljs-string">&quot;.<span class="hljs-subst">\n</span><span class="hljs-subst">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>    <span class="hljs-string">&quot;I&#x27;ll be &quot;</span> <span class="hljs-operator">+</span> (age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">+</span> <span class="hljs-string">&quot; years old next month.&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h4><p>定义数组有两种方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">list1</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// 定义了只有number类型数据的数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">list2</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// 使用泛型定义数组</span><br></code></pre></td></tr></table></figure><h4 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h4><p>元组类型允许表示一个<code>已知类型</code>和<code>已知数量</code>的数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">string</span>];<br>x = [<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;str&#x27;</span>]; <span class="hljs-comment">// OK</span><br>x = [<span class="hljs-string">&#x27;str&#x27;</span>, <span class="hljs-number">10</span>]; <span class="hljs-comment">// Error,数量和类型要一一对应。</span><br></code></pre></td></tr></table></figure><p>访问元素的某个方法时，会根据元素类型判断是否有某个方法。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x[<span class="hljs-number">1</span>].substr(<span class="hljs-number">1</span>)); <span class="hljs-comment">// OK</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x[<span class="hljs-number">0</span>].substr(<span class="hljs-number">1</span>)); <span class="hljs-comment">// Error,&#x27;number&#x27; does not have &#x27;substr&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h4><p>enum 类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">enum</span> <span class="hljs-variable">Color</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-built_in">Red</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Green</span><span class="hljs-operator">,</span> <span class="hljs-built_in">Blue</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-variable">let</span> <span class="hljs-variable">c</span><span class="hljs-operator">:</span> <span class="hljs-variable">Color</span> <span class="hljs-operator">=</span> <span class="hljs-variable">Color</span><span class="hljs-operator">.</span><span class="hljs-built_in">Green</span><span class="hljs-operator">;</span> <span class="hljs-operator">//</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以为元素编号</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">enum</span> Color &#123;Red = <span class="hljs-number">1</span>, Green = <span class="hljs-number">2</span>, Blue = <span class="hljs-number">4</span>&#125;<br><span class="hljs-attribute">let</span> c: Color = Color.Green; // c = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以根据编号反向查找相应的名字</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<span class="hljs-title class_">Red</span> = <span class="hljs-number">1</span>, <span class="hljs-title class_">Green</span>, <span class="hljs-title class_">Blue</span>&#125;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">colorName</span>: <span class="hljs-built_in">string</span> = <span class="hljs-title class_">Color</span>[<span class="hljs-number">2</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colorName);  <span class="hljs-comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span><br></code></pre></td></tr></table></figure><h4 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h4><p>有时有些变量并不清楚类型，例如来自用户的输入或第三方代码库，<br>此时如果只想代码通过编译检查，可以使用 any 类型来标记这些变量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">notSure</span>: <span class="hljs-built_in">any</span> = <span class="hljs-number">5</span>;<br>notSure = <span class="hljs-string">&quot;maybe a string instead&quot;</span>;<br>notSure = <span class="hljs-literal">false</span>; <span class="hljs-comment">// okay, definitely a boolean</span><br></code></pre></td></tr></table></figure><p>在改写代码的时候，any 允许在编译时选择性包含或移除类型检查。</p><h4 id="Void"><a href="#Void" class="headerlink" title="Void"></a>Void</h4><p>void 类型表示没有任何类型，当函数无返回值时，其返回值类型是 void</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">warnUser</span>(<span class="hljs-params"></span>): <span class="hljs-title function_">void</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;This is my warning message&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>声明 void 类型的变量，只能赋予 undefined 和 null</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-attr">unusable</span>: <span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><h4 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h4><p>默认 Null 和 Undefined 是所有类型的子类型，也就是可以将 null 和 undefined 赋值给其他类型。当指定了–strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们自己。 这能避免很多常见的问题。</p><h4 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h4><p>never 类型表示的是那些永不存在的值的类型。<br>never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span><span class="hljs-params">(message: string)</span>: never &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(message);<br>&#125;<br><br><span class="hljs-comment">// 推断的返回值类型为never</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fail</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> error(<span class="hljs-string">&quot;Something failed&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回never的函数必须存在无法达到的终点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">infiniteLoop</span><span class="hljs-params">()</span>: never &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>表示非基本类型，也就是除了 number，string，boolean，symbol，null 或 undefined 之外的类型。</p><h4 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h4><p>有时如果知道某个变量有比现有类型更确切的类型，可以使用类型断言对变量进行类型定义。</p><p>类型断言有两种形式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">someValue</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;this is a string&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (&lt;<span class="hljs-built_in">string</span>&gt;someValue).<span class="hljs-property">length</span>; <span class="hljs-comment">// 当中TS中使用JSX时，这种写法会产生冲突。</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">strLength</span>: <span class="hljs-built_in">number</span> = (someValue <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>).<span class="hljs-property">length</span>; <span class="hljs-comment">// 更推荐这种写法</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-字符串的新增方法</title>
    <link href="/article/4460526d.html"/>
    <url>/article/4460526d.html</url>
    
    <content type="html"><![CDATA[<img src="/article/4460526d/banner.jpg" class="" title="image"><h2 id="一、String-fromCodePoint"><a href="#一、String-fromCodePoint" class="headerlink" title="一、String.fromCodePoint()"></a>一、String.fromCodePoint()</h2><p>ES5 提供 String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于 0xFFFF 的字符。</p><p>ES6 提供了 String.fromCodePoint()方法，可以识别大于 0xFFFF 的字符，弥补了 String.fromCharCode()方法的不足。在作用上，正好与下面的 codePointAt()方法相反。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">String.fromCodePoint(<span class="hljs-number">0</span>x20BB7)<br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;𠮷&quot;</span><br>String.fromCodePoint(<span class="hljs-number">0</span>x78, <span class="hljs-number">0</span>x1f680, <span class="hljs-number">0</span>x79) === <span class="hljs-string">&#x27;x\uD83D\uDE80y&#x27;</span><br><span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure><p>注意，fromCodePoint 方法定义在 String 对象上，而 codePointAt 方法定义在字符串的实例对象上。</p><h2 id="二、String-raw"><a href="#二、String-raw" class="headerlink" title="二、String.raw()"></a>二、String.raw()</h2><p>该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">String.raw`Hi\n<span class="hljs-variable">$&#123;2+3&#125;</span>!`<br><span class="hljs-regexp">//</span> 实际返回 <span class="hljs-string">&quot;Hi\\n5!&quot;</span>，显示的是转义后的结果 <span class="hljs-string">&quot;Hi\n5!&quot;</span><br>String.raw`Hi\u000A!`;<br><span class="hljs-regexp">//</span> 实际返回 <span class="hljs-string">&quot;Hi\\u000A!&quot;</span>，显示的是转义后的结果 <span class="hljs-string">&quot;Hi\u000A!&quot;</span><br></code></pre></td></tr></table></figure><p>String.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p><p>String.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有 raw 属性的对象，且 raw 属性的值应该是一个数组，对应模板字符串解析后的值。</p><p>作为函数，String.raw()的代码实现基本如下。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">String.raw = <span class="hljs-keyword">function</span> <span class="hljs-params">(strings, <span class="hljs-rest_arg">...values</span>)</span> &#123;<br>  let output = <span class="hljs-string">&#x27;&#x27;</span>;<br>  let index;<br>  <span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; values.length; index++) &#123;<br>    output += strings.raw[index] + values[index];<br>  &#125;<br>  output += strings.raw[index]<br>  <span class="hljs-keyword">return</span> output;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、实例方法：codePointAt"><a href="#三、实例方法：codePointAt" class="headerlink" title="三、实例方法：codePointAt()"></a>三、实例方法：codePointAt()</h2><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">var s = <span class="hljs-string">&quot;𠮷&quot;</span>; <span class="hljs-regexp">//</span> 码点是<span class="hljs-number">0</span>x20BB7，大于<span class="hljs-number">0</span>xFFFF<br>s.length <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>s.charAt(<span class="hljs-number">0</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;&#x27;</span><br>s.charAt(<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;&#x27;</span><br>s.charCodeAt(<span class="hljs-number">0</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">55362</span><br>s.charCodeAt(<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">57271</span><br></code></pre></td></tr></table></figure><p>ES6 提供了 codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">let s = <span class="hljs-string">&#x27;𠮷a&#x27;</span>;<br>s.codePointAt(<span class="hljs-number">0</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">134071</span><br>s.codePointAt(<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">57271</span><br>s.codePointAt(<span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">97</span><br></code></pre></td></tr></table></figure><p>codePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用 toString()方法转换一下。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> s = &#x27;𠮷a&#x27;;<br>s.code<span class="hljs-constructor">PointAt(0)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(16)</span> <span class="hljs-comment">// &quot;20bb7&quot;</span><br>s.code<span class="hljs-constructor">PointAt(2)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(16)</span> <span class="hljs-comment">// &quot;61&quot;</span><br></code></pre></td></tr></table></figure><p>codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符 a 在字符串 s 的正确位置序号应该是 1，但是必须向 codePointAt()方法传入 2。解决这个问题的一个办法是使用 for…of 循环，因为它会正确识别 32 位的 UTF-16 字符。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> s = &#x27;𠮷a&#x27;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> ch <span class="hljs-keyword">of</span> s) &#123;<br>  console.log(ch.code<span class="hljs-constructor">PointAt(0)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String(16)</span>);<br>&#125;<br><span class="hljs-comment">// 20bb7</span><br><span class="hljs-comment">// 61</span><br></code></pre></td></tr></table></figure><p>另一种方法也可以，使用扩展运算符（…）进行展开运算。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let arr = [...<span class="hljs-string">&#x27;𠮷a&#x27;</span>]; <span class="hljs-comment">// arr.length === 2</span><br>arr.forEach(<br>  <span class="hljs-function"><span class="hljs-params">ch</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(ch.codePointAt(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>))<br>);<br><span class="hljs-comment">// 20bb7</span><br><span class="hljs-comment">// 61</span><br></code></pre></td></tr></table></figure><h2 id="四、实例方法：normalize"><a href="#四、实例方法：normalize" class="headerlink" title="四、实例方法：normalize()"></a>四、实例方法：normalize()</h2><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如 Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如 O（\u004F）和 ˇ（\u030C）合成 Ǒ（\u004F\u030C）。</p><p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;\u01D1&#x27;</span>===<span class="hljs-string">&#x27;\u004F\u030C&#x27;</span> <span class="hljs-regexp">//</span>false<br><span class="hljs-string">&#x27;\u01D1&#x27;</span>.length <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br><span class="hljs-string">&#x27;\u004F\u030C&#x27;</span>.length <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>ES6 提供字符串实例的 normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-string">&#x27;\u01D1&#x27;</span>.<span class="hljs-keyword">normalize</span>() === <span class="hljs-string">&#x27;\u004F\u030C&#x27;</span>.<span class="hljs-keyword">normalize</span>()<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>normalize 方法可以接受一个参数来指定 normalize 的方式，参数的四个可选值如下。</p><ul><li>NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li><li>NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li><li>NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize 方法不能识别中文。）</li><li>NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li></ul><h2 id="五、实例方法：includes-startsWith-endsWith"><a href="#五、实例方法：includes-startsWith-endsWith" class="headerlink" title="五、实例方法：includes(), startsWith(), endsWith()"></a>五、实例方法：includes(), startsWith(), endsWith()</h2><p>以前 JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><ul><li>includes()：返回布尔值，表示是否找到了参数字符串。</li><li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">let s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><br>s.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-regexp">//</span> true<br>s.endsWith(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-regexp">//</span> true<br>s.includes(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">let s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br>s.startsWith(<span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-regexp">//</span> true<br>s.endsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">5</span>) <span class="hljs-regexp">//</span> true<br>s.includes(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><p>使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。</p><h2 id="六、实例方法：repeat"><a href="#六、实例方法：repeat" class="headerlink" title="六、实例方法：repeat()"></a>六、实例方法：repeat()</h2><p>repeat 方法返回一个新字符串，表示将原字符串重复 n 次。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;hellohello&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">0</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>参数如果是小数，会被取整。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">2.9</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;nana&quot;</span><br></code></pre></td></tr></table></figure><p>如果 repeat 的参数是负数或者 Infinity，会报错。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-keyword">repeat</span><span class="hljs-comment">(Infinity)</span><br><span class="hljs-comment">// RangeError</span><br><span class="hljs-string">&#x27;na&#x27;</span>.<span class="hljs-keyword">repeat</span><span class="hljs-comment">(-1)</span><br><span class="hljs-comment">// RangeError</span><br></code></pre></td></tr></table></figure><p>0 到 1、0 到-1 以及 NaN 等同于 0。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">0.9</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(-<span class="hljs-number">0.9</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(NaN) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>如果 repeat 的参数是字符串，则会先转换成数字。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-string">&#x27;na&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;nanana&quot;</span><br></code></pre></td></tr></table></figure><h2 id="七、实例方法：padStart-，padEnd"><a href="#七、实例方法：padStart-，padEnd" class="headerlink" title="七、实例方法：padStart()，padEnd()"></a>七、实例方法：padStart()，padEnd()</h2><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;x&#x27;</span>.padStart(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;ababx&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padStart(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;abax&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padEnd(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xabab&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padEnd(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xaba&#x27;</span><br></code></pre></td></tr></table></figure><p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;xxx&#x27;</span>.padStart(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br><span class="hljs-string">&#x27;xxx&#x27;</span>.padEnd(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;xxx&#x27;</span><br></code></pre></td></tr></table></figure><p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;abc&#x27;</span>.padStart(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;0123456789&#x27;</span>)<br><span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;0123456abc&#x27;</span><br></code></pre></td></tr></table></figure><p>如果省略第二个参数，默认使用空格补全长度。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;x&#x27;</span>.padStart(<span class="hljs-number">4</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;   x&#x27;</span><br><span class="hljs-string">&#x27;x&#x27;</span>.padEnd(<span class="hljs-number">4</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;x   &#x27;</span><br></code></pre></td></tr></table></figure><h2 id="八、实例方法：trimStart-，trimEnd"><a href="#八、实例方法：trimStart-，trimEnd" class="headerlink" title="八、实例方法：trimStart()，trimEnd()"></a>八、实例方法：trimStart()，trimEnd()</h2><p>它们的行为与 trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">const s = <span class="hljs-string">&#x27;  abc  &#x27;</span>;<br>s.trim() <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;abc&quot;</span><br>s.trimStart() <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;abc  &quot;</span><br>s.trimEnd() <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;  abc&quot;</span><br></code></pre></td></tr></table></figure><p>除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。</p><p>浏览器还部署了额外的两个方法，trimLeft()是 trimStart()的别名，trimRight()是 trimEnd()的别名。</p><h2 id="九、实例方法：matchAll"><a href="#九、实例方法：matchAll" class="headerlink" title="九、实例方法：matchAll()"></a>九、实例方法：matchAll()</h2><p>matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/string-methods">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-字符串的扩展（下）</title>
    <link href="/article/88443906.html"/>
    <url>/article/88443906.html</url>
    
    <content type="html"><![CDATA[<img src="/article/88443906/banner.jpg" class="" title="image"><h2 id="一、模板字符串"><a href="#一、模板字符串" class="headerlink" title="一、模板字符串"></a>一、模板字符串</h2><p>以前输出模板通常是采用字符串拼接</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-string">&quot;hello world&quot;</span> + <span class="hljs-keyword">name</span><br></code></pre></td></tr></table></figure><p>引入模板字符串后，采用反引号做标识，使用${}包裹变量。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`hello world <span class="hljs-subst">$&#123; name &#125;</span>`</span><br></code></pre></td></tr></table></figure><p>${}大括号内部可以放入任意的 JavaScript 表达式，可以进行运算以及引用对象属性，可以调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// JavaScript 表达式</span><br><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span>;<br><br><span class="hljs-string">`<span class="hljs-subst">$&#123;x&#125;</span> + <span class="hljs-subst">$&#123;y * <span class="hljs-number">2</span>&#125;</span> = <span class="hljs-subst">$&#123;x + y * <span class="hljs-number">2</span>&#125;</span>`</span><br><span class="hljs-comment">// &quot;1 + 4 = 5&quot;</span><br><br><span class="hljs-comment">// 引用对象属性</span><br><span class="hljs-keyword">let</span> obj = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-string">`<span class="hljs-subst">$&#123;obj.x + obj.y&#125;</span>`</span><br><span class="hljs-comment">// &quot;3&quot;</span><br><br><span class="hljs-comment">// 调用函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>&#125;<br><span class="hljs-string">`foo <span class="hljs-subst">$&#123;fn()&#125;</span> bar`</span><br><span class="hljs-comment">// foo Hello World bar</span><br></code></pre></td></tr></table></figure><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法。</p><h2 id="二、实例：模板编译"><a href="#二、实例：模板编译" class="headerlink" title="二、实例：模板编译"></a>二、实例：模板编译</h2><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bnf">let template = `<br><span class="hljs-attribute">&lt;ul&gt;</span><br>  <span class="hljs-attribute">&lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</span><br>    <span class="hljs-attribute">&lt;li&gt;</span><span class="hljs-attribute">&lt;%= data.supplies[i] %&gt;</span><span class="hljs-attribute">&lt;/li&gt;</span><br>  <span class="hljs-attribute">&lt;% &#125; %&gt;</span><br><span class="hljs-attribute">&lt;/ul&gt;</span><br>`;<br></code></pre></td></tr></table></figure><p>使用正则转换成表达式字符串</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let evalExpr = <span class="hljs-regexp">/&lt;%=(.+?)%&gt;/g</span>;<br>let expr = <span class="hljs-regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;<br>template = template<br>  .<span class="hljs-built_in">replace</span>(evalExpr, <span class="hljs-string">&#x27;`); \n  echo( $1 ); \n  echo(`&#x27;</span>)<br>  .<span class="hljs-built_in">replace</span>(expr, <span class="hljs-string">&#x27;`); \n $1 \n  echo(`&#x27;</span>);<br>template = <span class="hljs-string">&#x27;echo(`&#x27;</span> + template + <span class="hljs-string">&#x27;`);&#x27;</span>;<br></code></pre></td></tr></table></figure><p>然后，将 template 封装在一个函数里面返回，就可以了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">let script =<br>`(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span><span class="hljs-params">(data)</span></span>&#123;<br>  let <span class="hljs-built_in">output</span> = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echo</span><span class="hljs-params">(html)</span></span>&#123;<br>    <span class="hljs-built_in">output</span> += html;<br>  &#125;<br>  $&#123; template &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">output</span>;<br>&#125;)`;<br><span class="hljs-keyword">return</span> script;<br></code></pre></td></tr></table></figure><p>完整 compile 函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> compile(template)&#123;<br>  const evalExpr = /&lt;%=(.+?)%&gt;/g;<br>  const <span class="hljs-built_in">expr</span> = /&lt;%([\s\S]+?)%&gt;/g;<br>  template = template<br>    .replace(evalExpr, <span class="hljs-string">&#x27;`); \n  echo( $1 ); \n  echo(`&#x27;</span>)<br>    .replace(<span class="hljs-built_in">expr</span>, <span class="hljs-string">&#x27;`); \n $1 \n  echo(`&#x27;</span>);<br>  template = <span class="hljs-string">&#x27;echo(`&#x27;</span> + template + <span class="hljs-string">&#x27;`);&#x27;</span>;<br>  <span class="hljs-built_in">let</span> script =<br>  `(<span class="hljs-keyword">function</span> parse(data)&#123;<br>    <span class="hljs-built_in">let</span> output = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-built_in">echo</span>(html)&#123;<br>      output += html;<br>    &#125;<br>    <span class="hljs-variable">$&#123; template &#125;</span><br>    <span class="hljs-built_in">return</span> output;<br>  &#125;)`;<br>  <span class="hljs-built_in">return</span> script;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、标签模板"><a href="#三、标签模板" class="headerlink" title="三、标签模板"></a>三、标签模板</h2><p>紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">alert`hello`<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-title">alert</span><span class="hljs-params">([<span class="hljs-string">&#x27;hello&#x27;</span>])</span></span><br></code></pre></td></tr></table></figure><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> b = <span class="hljs-number">10</span>;<br>tag<span class="hljs-string">`Hello <span class="hljs-subst">$&#123; a + b &#125;</span> world <span class="hljs-subst">$&#123; a * b &#125;</span>`</span>;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-title function_">tag</span>([<span class="hljs-string">&#x27;Hello &#x27;</span>, <span class="hljs-string">&#x27; world &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>], <span class="hljs-number">15</span>, <span class="hljs-number">50</span>);<br></code></pre></td></tr></table></figure><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message =<br>  <span class="hljs-title class_">SaferHTML</span><span class="hljs-string">`&lt;p&gt;<span class="hljs-subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SaferHTML</span>(<span class="hljs-params">templateData</span>) &#123;<br>  <span class="hljs-keyword">let</span> s = templateData[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> arg = <span class="hljs-title class_">String</span>(<span class="hljs-variable language_">arguments</span>[i]);<br>    <span class="hljs-comment">// Escape special characters in the substitution.</span><br>    s += arg.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">&quot;&amp;amp;&quot;</span>)<br>            .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&quot;&amp;lt;&quot;</span>)<br>            .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&quot;&amp;gt;&quot;</span>);<br>    <span class="hljs-comment">// Don&#x27;t escape special characters in the template.</span><br>    s += templateData[i];<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">i18n`Welcome to <span class="hljs-variable">$&#123;siteName&#125;</span>, you are visitor number <span class="hljs-variable">$&#123;visitorNumber&#125;</span>!`<br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;欢迎访问xxx，您是第xxxx位访问者！&quot;</span><br></code></pre></td></tr></table></figure><h2 id="四、模板字符串的限制"><a href="#四、模板字符串的限制" class="headerlink" title="四、模板字符串的限制"></a>四、模板字符串的限制</h2><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p><p>为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回 undefined，而不是报错，并且从 raw 属性上面可以得到原始字符串。</p><p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/string">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-字符串的扩展（上）</title>
    <link href="/article/888cebaf.html"/>
    <url>/article/888cebaf.html</url>
    
    <content type="html"><![CDATA[<img src="/article/888cebaf/banner.jpg" class="" title="image"><h2 id="一、字符的-Unicode-表示法"><a href="#一、字符的-Unicode-表示法" class="headerlink" title="一、字符的 Unicode 表示法"></a>一、字符的 Unicode 表示法</h2><p>ES6 加强了对 Unicode 的支持，允许采用\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;\u0061&quot;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p>但是，这种表示法只限于码点在\u0000~\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;\uD842\uDFB7&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;𠮷&quot;</span><br><span class="hljs-string">&quot;\u20BB7&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot; 7&quot;</span> 该段被理解为\u20BB+<span class="hljs-number">7</span>，而\u20BB是不可打印字符，因此以空格显示，其后跟着一个 <span class="hljs-number">7</span>。<br></code></pre></td></tr></table></figure><p>改进后，只需将码点放入大括号中，即可正确解读。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&quot;\u&#123;20BB7&#125;&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;𠮷&quot;</span><br><br><span class="hljs-string">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;ABC&quot;</span><br><br>let hello = <span class="hljs-number">123</span>;<br>hell\u&#123;<span class="hljs-number">6</span>F&#125; <span class="hljs-regexp">//</span> <span class="hljs-number">123</span><br><br><span class="hljs-string">&#x27;\u&#123;1F680&#125;&#x27;</span> === <span class="hljs-string">&#x27;\uD83D\uDE80&#x27;</span><br><span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure><h2 id="二、字符串的遍历器接口"><a href="#二、字符串的遍历器接口" class="headerlink" title="二、字符串的遍历器接口"></a>二、字符串的遍历器接口</h2><p>ES6 为字符串添加了 Iterator 接口，使得字符串可以被 for…of 循环遍历。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span> (let codePoint of <span class="hljs-string">&#x27;foo&#x27;</span>) &#123;<br>  console.log(codePoint)<br>&#125;<br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;f&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;o&quot;</span><br><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;o&quot;</span><br></code></pre></td></tr></table></figure><p>并且这个遍历器可以识别码点大于 0xFFFF 的码点，原本的 for 循环无法识别。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">let <span class="hljs-built_in">text</span> = String.<span class="hljs-built_in">fromCodePoint</span>(<span class="hljs-number">0x20BB7</span>);<br><br><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">text</span>.<span class="hljs-built_in">length</span>; i++) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">text</span>[i]);<br>&#125;<br><span class="hljs-comment">// &quot; &quot;</span><br><span class="hljs-comment">// &quot; &quot;</span><br><br><span class="hljs-keyword">for</span> (let i of <span class="hljs-built_in">text</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i);<br>&#125;<br><span class="hljs-comment">// &quot;𠮷&quot;</span><br></code></pre></td></tr></table></figure><h2 id="三、JSON-stringify-的改造"><a href="#三、JSON-stringify-的改造" class="headerlink" title="三、JSON.stringify() 的改造"></a>三、JSON.stringify() 的改造</h2><p>根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的 JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。</p><p>具体来说，UTF-8 标准规定，0xD800 到 0xDFFF 之间的码点，不能单独使用，必须配对使用。比如，\uD834\uDF06 是两个码点，但是必须放在一起配对使用，代表字符 𝌆。这是为了表示码点大于 0xFFFF 的字符的一种变通方法。单独使用\uD834 和\uDFO6 这两个码点是不合法的，或者颠倒顺序也不行，因为\uDF06\uD834 并没有对应的字符。</p><p>JSON.stringify()的问题在于，它可能返回 0xD800 到 0xDFFF 之间的单个码点。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">JSON.stringify(<span class="hljs-string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;\u&#123;D834&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>为了确保返回的是合法的 UTF-8 字符，ES2019 改变了 JSON.stringify()的行为。如果遇到 0xD800 到 0xDFFF 之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">JSON.stringify(<span class="hljs-string">&#x27;\u&#123;D834&#125;&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span>\\uD834<span class="hljs-string">&quot;&quot;</span><br>JSON.stringify(<span class="hljs-string">&#x27;\uDF06\uD834&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;&quot;</span>\\udf06\\ud834<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/string">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20220717-孙文西路文化旅游步行街</title>
    <link href="/article/7e908282.html"/>
    <url>/article/7e908282.html</url>
    
    <content type="html"><![CDATA[<img src="/article/7e908282/banner.jpg" class="" title="image"><p><strong><em>应届毕业后来到中山工作，初到中山到今天已经有一个月，从开始工作到今天也已经三周有余。每天除了坐在电脑前码代码，就没有别的活动了，并且因为是单休，工作六天后也很难提起劲到处走走。今天心情好，随手在某度地图搜了一下周边，就锁定了孙文西路文化旅游步行街。顺手拍了几张照片，浅浅修了一下。</em></strong></p><h2 id="1、恩豪大酒店"><a href="#1、恩豪大酒店" class="headerlink" title="1、恩豪大酒店"></a>1、恩豪大酒店</h2><img src="/article/7e908282/hotel.jpg" class="" title="image"><h2 id="2、步行街一角"><a href="#2、步行街一角" class="headerlink" title="2、步行街一角"></a>2、步行街一角</h2><img src="/article/7e908282/WalkingStreet1.jpg" class="" title="image"><img src="/article/7e908282/WalkingStreet2.jpg" class="" title="image"><h2 id="3、烟墩山塔"><a href="#3、烟墩山塔" class="headerlink" title="3、烟墩山塔"></a>3、烟墩山塔</h2><img src="/article/7e908282/tower.jpg" class="" title="image">]]></content>
    
    
    <categories>
      
      <category>Relax</category>
      
    </categories>
    
    
    <tags>
      
      <tag>relax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-其他的解构以及解构赋值的用途</title>
    <link href="/article/ae9359db.html"/>
    <url>/article/ae9359db.html</url>
    
    <content type="html"><![CDATA[<img src="/article/ae9359db/banner.jpg" class="" title="image"><h2 id="一、数值和布尔值的解构赋值"><a href="#一、数值和布尔值的解构赋值" class="headerlink" title="一、数值和布尔值的解构赋值"></a>一、数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> &#123;<span class="hljs-built_in">toString</span>: s&#125; = <span class="hljs-number">123</span>;<br><span class="hljs-attr">s</span> === Number.prototype.<span class="hljs-built_in">toString</span> // <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-built_in">toString</span>: s&#125; = <span class="hljs-literal">true</span>;<br><span class="hljs-attr">s</span> === Boolean.prototype.<span class="hljs-built_in">toString</span> // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">prop</span>: x &#125; = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// TypeError</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">prop</span>: y &#125; = <span class="hljs-literal">null</span>; <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><h2 id="二、函数参数的解构赋值"><a href="#二、函数参数的解构赋值" class="headerlink" title="二、函数参数的解构赋值"></a>二、函数参数的解构赋值</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>([x, y])&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">x</span> + y;<br>&#125;<br>add([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]); // <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>函数 add 的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量 x 和 y。对于函数内部的代码来说，它们能感受到的参数就是 x 和 y。</p><p><strong><em>函数参数的解构也可以使用默认值。</em></strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">function move(&#123;x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>&#125; = &#123;&#125;) &#123;<br>  return <span class="hljs-selector-attr">[x, y]</span>;<br>&#125;<br>move(&#123;x: <span class="hljs-number">3</span>, y: <span class="hljs-number">8</span>&#125;); <span class="hljs-comment">// [3, 8]</span><br>move(&#123;x: <span class="hljs-number">3</span>&#125;); <span class="hljs-comment">// [3, 0]</span><br>move(&#123;&#125;); <span class="hljs-comment">// [0, 0]</span><br>move(); <span class="hljs-comment">// [0, 0]</span><br></code></pre></td></tr></table></figure><p>注意区别，下面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">function move(&#123;x, y&#125; = &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> &#125;) &#123;<br>  return <span class="hljs-selector-attr">[x, y]</span>;<br>&#125;<br>move(&#123;x: <span class="hljs-number">3</span>, y: <span class="hljs-number">8</span>&#125;); <span class="hljs-comment">// [3, 8]</span><br>move(&#123;x: <span class="hljs-number">3</span>&#125;); <span class="hljs-comment">// [3, undefined]</span><br>move(&#123;&#125;); <span class="hljs-comment">// [undefined, undefined]</span><br>move(); <span class="hljs-comment">// [0, 0]</span><br></code></pre></td></tr></table></figure><h2 id="三、圆括号问题"><a href="#三、圆括号问题" class="headerlink" title="三、圆括号问题"></a>三、圆括号问题</h2><p>对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p><p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。<br>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p><p>以下三种解构赋值不得使用圆括号。<br>（1）变量声明语句</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">全部报错</span><br><span class="hljs-string">let</span> [<span class="hljs-string">(a)</span>] <span class="hljs-string">=</span> [<span class="hljs-number">1</span>]<span class="hljs-string">;</span><br><span class="hljs-string">let</span> &#123; <span class="hljs-attr">o:</span> <span class="hljs-string">(</span>&#123; <span class="hljs-attr">p:</span> <span class="hljs-string">p</span> &#125;<span class="hljs-string">)</span> &#125; <span class="hljs-string">=</span> &#123; <span class="hljs-attr">o:</span> &#123; <span class="hljs-attr">p:</span> <span class="hljs-number">2</span> &#125; &#125;<span class="hljs-string">;</span><br></code></pre></td></tr></table></figure><p>（2）函数参数<br>函数参数也属于变量声明，因此不能带有圆括号</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">// 报错<br><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>([(z)]) &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">z</span>; &#125;<br>// 报错<br><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>([z,(x)]) &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">x</span>; &#125;<br></code></pre></td></tr></table></figure><p>（3）赋值语句的模式</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">// 全部报错</span><br><span class="hljs-comment">(&#123; p: a &#125;)</span> = &#123; p: <span class="hljs-number">42</span> &#125;;<br><span class="hljs-comment">([a])</span> = [<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">[(b)] = [<span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> 正确<br>(&#123; p: (d) &#125; = &#123;&#125;); <span class="hljs-regexp">//</span> 正确<br>[(parseInt.prop)] = [<span class="hljs-number">3</span>]; <span class="hljs-regexp">//</span> 正确<br></code></pre></td></tr></table></figure><h2 id="四、用途"><a href="#四、用途" class="headerlink" title="四、用途"></a>四、用途</h2><p>（1）交换变量的值</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span>;<br>[<span class="hljs-meta">x, y</span>] = [y, x];<br></code></pre></td></tr></table></figure><p>（2）从函数返回多个值</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ada">// 返回一个数组<br><span class="hljs-keyword">function</span> <span class="hljs-title">example</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">[1,</span> <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br>let [a, b, c] = example();<br><br>// 返回一个对象<br><span class="hljs-keyword">function</span> <span class="hljs-title">example</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">&#123;</span><br>    foo: <span class="hljs-number">1</span>,<br>    bar: <span class="hljs-number">2</span><br>  &#125;;<br>&#125;<br>let &#123; foo, bar &#125; = example();<br></code></pre></td></tr></table></figure><p>（3）函数参数的定义<br>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 参数是一组有次序的值</span><br>function <span class="hljs-built_in">f</span>([x, y, z]) &#123; ... &#125;<br><span class="hljs-built_in">f</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br><br><span class="hljs-comment">// 参数是一组无次序的值</span><br>function <span class="hljs-built_in">f</span>(&#123;x, y, z&#125;) &#123; ... &#125;<br><span class="hljs-built_in">f</span>(&#123;z: <span class="hljs-number">3</span>, y: <span class="hljs-number">2</span>, x: <span class="hljs-number">1</span>&#125;);<br></code></pre></td></tr></table></figure><p>（4）提取 JSON 数据</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> jsonData = &#123;<br> <span class="hljs-built_in"> id</span>: <span class="hljs-number">42</span>,<br>  status: <span class="hljs-string">&quot;OK&quot;</span>,<br>  data: [<span class="hljs-number">867</span>, <span class="hljs-number">5309</span>]<br>&#125;;<br><span class="hljs-keyword">let</span> &#123;<span class="hljs-built_in"> id</span>, status, data:<span class="hljs-built_in"> number</span> &#125; = jsonData;<br>console.log<span class="hljs-built_in">(id</span>, status,<span class="hljs-built_in"> number</span>);<br>// <span class="hljs-number">42</span>, <span class="hljs-string">&quot;OK&quot;</span>, [<span class="hljs-number">867</span>, <span class="hljs-number">5309</span>]<br></code></pre></td></tr></table></figure><p>（5）函数参数的默认值<br>指定参数的默认值，就避免了在函数体内部再写 var foo &#x3D; config.foo || ‘default foo’;这样的语句。</p><p>（6）遍历 Map 结构<br>任何部署了 Iterator 接口的对象，都可以用 for…of 循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs maxima">const <span class="hljs-built_in">map</span> = <span class="hljs-built_in">new</span> Map();<br><span class="hljs-built_in">map</span>.set(&#x27;<span class="hljs-built_in">first</span>&#x27;, &#x27;hello&#x27;);<br><span class="hljs-built_in">map</span>.set(&#x27;<span class="hljs-built_in">second</span>&#x27;, &#x27;world&#x27;);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> [<span class="hljs-built_in">key</span>, value] of <span class="hljs-built_in">map</span>) &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">key</span> + <span class="hljs-string">&quot; is &quot;</span> + value);<br>&#125;<br>// <span class="hljs-built_in">first</span> <span class="hljs-built_in">is</span> hello<br>// <span class="hljs-built_in">second</span> <span class="hljs-built_in">is</span> world<br></code></pre></td></tr></table></figure><p>（7）输入模块的指定方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-title class_">SourceMapConsumer</span>, <span class="hljs-title class_">SourceNode</span> &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;source-map&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/destructuring">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识RxJS与demo实践</title>
    <link href="/article/222d0cce.html"/>
    <url>/article/222d0cce.html</url>
    
    <content type="html"><![CDATA[<img src="/article/222d0cce/banner.jpg" class="" title="新兰永恒 image"><h2 id="一、核心概念"><a href="#一、核心概念" class="headerlink" title="一、核心概念"></a>一、核心概念</h2><blockquote><p>RxJS 中 Stream 的概念：将不断产生的数据或事件组成序列称作 Stream。</p></blockquote><p>1.Observable：被观察的对象，代表未来可能产生的数据或事件的集合。</p><p>2.Observer：观察者，通常是回调函数，用来接收观察结果。其中包括三个属性（next，complete、error）。</p><p>3.Subscription：订阅对象，用于建立 Observer 与 Observable 的联系（也可以取消订阅）。</p><p>4.operators：运算符，对 Observable 产生的数据或事件进行处理的纯函数。常见的运算符有 map、filter、delay 等。</p><p>5.Subject：主体，如同 EventEmitter，用于将 Observable 广播给多个 Observer。在这种情况下，Subject 即是 Observer 又是 Observable。</p><img src="/article/222d0cce/subject%E5%B9%BF%E6%92%AD%E5%9B%BE.jpg" class="" title="Subject广播关系图 image"><h2 id="二、第一个示例"><a href="#二、第一个示例" class="headerlink" title="二、第一个示例"></a>二、第一个示例</h2><p>通常，原生 js 采用如下方式注册事件监听。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">document.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;Clicked!&#x27;</span>));<br></code></pre></td></tr></table></figure><p>使用 RxJS 可以创建 Observable。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> &#123; fromEvent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><br>fromEvent(document, <span class="hljs-string">&#x27;click&#x27;</span>).subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> console.log(<span class="hljs-string">&#x27;Clicked!&#x27;</span>));<br></code></pre></td></tr></table></figure><h2 id="三、Demo"><a href="#三、Demo" class="headerlink" title="三、Demo"></a>三、Demo</h2><h4 id="1-安装-RxJS"><a href="#1-安装-RxJS" class="headerlink" title="1.安装 RxJS"></a>1.安装 RxJS</h4><p>因为只是跑简单示例，所以并没有用构建工具初始化项目。创建 HTML 文件，采用 CDN 引入的方式使用 RxJS。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/rxjs@^7/dist/bundles/rxjs.umd.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">const &#123; &#125; <span class="hljs-operator">=</span> rxjs<span class="hljs-comment">; // 使用ES6解构赋值按需引入</span><br>const &#123; &#125; <span class="hljs-operator">=</span> rxjs.operators<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果构建项目，则需要使用 <strong>npm install rxjs</strong>来安装 RxJS。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>; <span class="hljs-comment">// 采用import语法引入</span><br><span class="hljs-keyword">import</span> &#123; &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs/operators&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="2-例子一：监听点击事件并输出前三次的数据。"><a href="#2-例子一：监听点击事件并输出前三次的数据。" class="headerlink" title="2.例子一：监听点击事件并输出前三次的数据。"></a>2.例子一：监听点击事件并输出前三次的数据。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; fromEvent &#125; = rxjs;<br><span class="hljs-keyword">const</span> &#123; take &#125;  = rxjs.<span class="hljs-property">operators</span>;<br><br><span class="hljs-keyword">let</span> btnDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.btn&quot;</span>);<br><span class="hljs-title function_">fromEvent</span>(btnDom, <span class="hljs-string">&#x27;click&#x27;</span>).<span class="hljs-title function_">pipe</span>(<br>    <span class="hljs-title function_">take</span>(<span class="hljs-number">3</span>)<br>).<span class="hljs-title function_">subscribe</span>(<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span><br>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    其中fromEvent(btnDom, &#x27;click&#x27;) 为 Observable；</span><br><span class="hljs-comment">    take(3) 为 Operators；</span><br><span class="hljs-comment">    console.log 为 Observer</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="3-例子二：点击按钮延时三秒输出结果。"><a href="#3-例子二：点击按钮延时三秒输出结果。" class="headerlink" title="3.例子二：点击按钮延时三秒输出结果。"></a>3.例子二：点击按钮延时三秒输出结果。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; fromEvent &#125; = rxjs;<br><span class="hljs-keyword">const</span> &#123; take, delay &#125; = rxjs.<span class="hljs-property">operators</span>;<br><br><span class="hljs-keyword">let</span> btnDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;.btn&quot;</span>);<br><span class="hljs-title function_">fromEvent</span>(btnDom, <span class="hljs-string">&#x27;click&#x27;</span>).<span class="hljs-title function_">pipe</span>(<br>    <span class="hljs-title function_">delay</span>(<span class="hljs-number">3000</span>),<br>    <span class="hljs-title function_">take</span>(<span class="hljs-number">3</span>)<br>).<span class="hljs-title function_">subscribe</span>(<br>    <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;点击按钮后延时三秒输出&quot;</span>);<br>    &#125;<br>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    其中fromEvent(btnDom, &#x27;click&#x27;) 为 Observable；</span><br><span class="hljs-comment">    delay(3000), take(3) 为 Operators；</span><br><span class="hljs-comment">    () =&gt; &#123;</span><br><span class="hljs-comment">        console.log(&quot;点击按钮后延时三秒输出&quot;);</span><br><span class="hljs-comment">    &#125; 为 Observer</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="部分内容来自RxJS-官方文档"><a href="#部分内容来自RxJS-官方文档" class="headerlink" title="部分内容来自RxJS 官方文档"></a>部分内容来自<a href="https://rxjs.dev/">RxJS 官方文档</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>RxJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-解构赋值之对象</title>
    <link href="/article/51fe8215.html"/>
    <url>/article/51fe8215.html</url>
    
    <content type="html"><![CDATA[<img src="/article/51fe8215/banner.jpg" class="" title="image"><h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">let &#123; foo, bar &#125; = &#123; foo: <span class="hljs-string">&#x27;aaa&#x27;</span>, bar: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>foo <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;aaa&quot;</span><br>bar <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;bbb&quot;</span><br></code></pre></td></tr></table></figure><p><strong><em>（1）对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</em></strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">let &#123; baz &#125; = &#123; foo: <span class="hljs-string">&#x27;aaa&#x27;</span>, bar: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>baz <span class="hljs-regexp">//</span> undefined<br></code></pre></td></tr></table></figure><p>（2）对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 例一</span><br>let &#123; <span class="hljs-built_in">log</span>, <span class="hljs-built_in">sin</span>, <span class="hljs-built_in">cos</span> &#125; = Math;<br><br><span class="hljs-comment">// 例二</span><br>const &#123; <span class="hljs-built_in">log</span> &#125; = <span class="hljs-built_in">console</span>;<br><span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>) <span class="hljs-comment">// hello</span><br>~~~<br></code></pre></td></tr></table></figure><p>（3） 如果变量名与属性名不一致，必须写成下面这样。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">let &#123; foo: baz &#125; = &#123; foo: <span class="hljs-string">&#x27;aaa&#x27;</span>, bar: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>baz <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;aaa&quot;</span><br><br>let obj = &#123; first: <span class="hljs-string">&#x27;hello&#x27;</span>, last: <span class="hljs-string">&#x27;world&#x27;</span> &#125;;<br>let &#123; first: f, last: l &#125; = obj;<br>f <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;hello&#x27;</span><br>l <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;world&#x27;</span><br></code></pre></td></tr></table></figure><p>这实际上说明，对象的解构赋值是下面形式的简写</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">let</span> &#123; foo: foo, <span class="hljs-built_in">bar</span>: <span class="hljs-built_in">bar</span> &#125; = &#123; foo: &#x27;aaa&#x27;, <span class="hljs-built_in">bar</span>: &#x27;bbb&#x27; &#125;;<br></code></pre></td></tr></table></figure><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">let &#123; foo: baz &#125; = &#123; foo: <span class="hljs-string">&#x27;aaa&#x27;</span>, bar: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;<br>baz <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;aaa&quot;</span><br>foo <span class="hljs-regexp">//</span> error: foo is not defined<br></code></pre></td></tr></table></figure><h2 id="二、默认值"><a href="#二、默认值" class="headerlink" title="二、默认值"></a>二、默认值</h2><p>生效条件是对象的属性值严格等于 undefined</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">var &#123;x = <span class="hljs-number">3</span>&#125; = &#123;&#125;;<br>x <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>var &#123;x, y = <span class="hljs-number">5</span>&#125; = &#123;x: <span class="hljs-number">1</span>&#125;;<br>x <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>y <span class="hljs-regexp">//</span> <span class="hljs-number">5</span><br><br>var &#123;x: y = <span class="hljs-number">3</span>&#125; = &#123;&#125;;<br>y <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>var &#123;x: y = <span class="hljs-number">3</span>&#125; = &#123;x: <span class="hljs-number">5</span>&#125;;<br>y <span class="hljs-regexp">//</span> <span class="hljs-number">5</span><br><br>var &#123; message: msg = <span class="hljs-string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;<br>msg <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Something went wrong&quot;</span><br></code></pre></td></tr></table></figure><h2 id="三、注意"><a href="#三、注意" class="headerlink" title="三、注意"></a>三、注意</h2><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">let</span> &#123;<span class="hljs-number">0</span> : <span class="hljs-built_in">first</span>, [arr.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>] : <span class="hljs-built_in">last</span>&#125; = arr;<br><span class="hljs-built_in">first</span> // <span class="hljs-number">1</span><br><span class="hljs-built_in">last</span> // <span class="hljs-number">3</span><br><br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/destructuring">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-解构赋值之数组</title>
    <link href="/article/fb4464e6.html"/>
    <url>/article/fb4464e6.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、基本用法"><a href="#一、基本用法" class="headerlink" title="一、基本用法"></a>一、基本用法</h2><p>（1）ES6 可以从数组中提取值，按照对应位置，对变量赋值。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">let <span class="hljs-comment">[a, b, c]</span> = <span class="hljs-comment">[1, 2, 3]</span>;<br></code></pre></td></tr></table></figure><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。<br>其他的解构例子如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">let [foo, [[bar], baz]] = [<span class="hljs-number">1</span>, [[<span class="hljs-number">2</span>], <span class="hljs-number">3</span>]];<br>foo <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>bar <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>baz <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>let [ , , third] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>third <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><br>let [head, ...tail] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>head <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>tail <span class="hljs-regexp">//</span> [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>（2）如果解构不成功，变量的值就等于 undefined。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">let <span class="hljs-comment">[foo]</span> = <span class="hljs-comment">[]</span>;<br>let <span class="hljs-comment">[bar, foo]</span> = <span class="hljs-comment">[1]</span>;<br></code></pre></td></tr></table></figure><p>（3）另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">let [x, y] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>x <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>y <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>let [a, [b], d] = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">4</span>];<br>a <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>b <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br>d <span class="hljs-regexp">//</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>（4）如果等号的右边不是数组（或者说不是可遍历的结构），那么将会报错。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 报错<br>let [foo] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> false<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> NaN<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> undefined<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> null<span class="hljs-comment">;</span><br>let [foo] <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。<br>（5）Set 结构可以解构赋值，实际上，只要某种数据结构具有 Iterator 接口，就可以采用数组形式的解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [x, y, z] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]);<br>x <span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></td></tr></table></figure><h2 id="二、默认值"><a href="#二、默认值" class="headerlink" title="二、默认值"></a>二、默认值</h2><p>（1）解构赋值允许指定默认值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">let [foo = true] = [];<br>foo <span class="hljs-regexp">//</span> true<br><br>let [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>]; <span class="hljs-regexp">//</span> x=<span class="hljs-string">&#x27;a&#x27;</span>, y=<span class="hljs-string">&#x27;b&#x27;</span><br>let [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>, undefined]; <span class="hljs-regexp">//</span> x=<span class="hljs-string">&#x27;a&#x27;</span>, y=<span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>注意：只有当数组成员严格等于 undefined，默认值才会生效，使用严格相等运算符（&#x3D;&#x3D;&#x3D;）来判断是否 undefined。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>] <span class="hljs-operator">=</span> [undefined]<span class="hljs-comment">;</span><br><span class="hljs-keyword">x</span> // <span class="hljs-number">1</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>] <span class="hljs-operator">=</span> [<span class="hljs-keyword">null</span>]<span class="hljs-comment">;</span><br><span class="hljs-keyword">x</span> // <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span>不严格等于undefined<br></code></pre></td></tr></table></figure><p>（2）如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">let</span> [x = <span class="hljs-title function_">f</span>()] = [<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// 等价于如下代码</span><br><br><span class="hljs-keyword">let</span> x;<br><span class="hljs-keyword">if</span> ([<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>) &#123;<br>  x = <span class="hljs-title function_">f</span>();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  x = [<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>（3）默认值可以引用解构赋值的其他变量，但必须已经声明。</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> []<span class="hljs-comment">;     // x=1; y=1</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">2</span>]<span class="hljs-comment">;    // x=2; y=2</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-keyword">x</span>] <span class="hljs-operator">=</span> [<span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">2</span>]<span class="hljs-comment">; // x=1; y=2</span><br>let [<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> y<span class="hljs-punctuation">,</span> y <span class="hljs-operator">=</span> <span class="hljs-number">1</span>] <span class="hljs-operator">=</span> []<span class="hljs-comment">;     // ReferenceError: y is not defined</span><br></code></pre></td></tr></table></figure><h2 id="三、特殊的"><a href="#三、特殊的" class="headerlink" title="三、特殊的"></a>三、特殊的</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">const [a, b, c, d, e] = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>a <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;h&quot;</span><br>b <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;e&quot;</span><br>c <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;l&quot;</span><br>d <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;l&quot;</span><br>e <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;o&quot;</span><br></code></pre></td></tr></table></figure><p>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">let &#123;length : <span class="hljs-built_in">len</span>&#125; = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-built_in">len</span> <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/destructuring">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-let和const（下）</title>
    <link href="/article/a5594629.html"/>
    <url>/article/a5594629.html</url>
    
    <content type="html"><![CDATA[<img src="/article/a5594629/banner.png" class="" title="image"><h2 id="一、const-基本用法"><a href="#一、const-基本用法" class="headerlink" title="一、const 基本用法"></a>一、const 基本用法</h2><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-literal">PI</span> = <span class="hljs-number">3.1415</span>;<br><span class="hljs-literal">PI</span> <span class="hljs-comment">// 3.1415</span><br><span class="hljs-literal">PI</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// TypeError: Assignment to constant variable.</span><br></code></pre></td></tr></table></figure><p>const 声明的变量不得改变值，这意味着，const 一旦声明变量，就必须立即初始化，不能留到以后赋值。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> foo; <span class="hljs-comment">// SyntaxError: Missing initializer in const declaration</span><br></code></pre></td></tr></table></figure><p>const 的作用域与 let 命令相同：只在声明所在的块级作用域内有效。const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。const 声明的常量，也与 let 一样不可重复声明。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  const <span class="hljs-built_in">MAX</span> = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-built_in">MAX</span> <span class="hljs-comment">// Uncaught ReferenceError: MAX is not defined</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">MAX</span>); <span class="hljs-comment">// ReferenceError</span><br>  const <span class="hljs-built_in">MAX</span> = <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> message = <span class="hljs-string">&quot;Hello!&quot;</span>;<br>let age = <span class="hljs-number">25</span>;<br><span class="hljs-comment">// 以下两行都会报错</span><br>const message = <span class="hljs-string">&quot;Goodbye!&quot;</span>;<br>const age = <span class="hljs-number">30</span>;<br>~~~<br></code></pre></td></tr></table></figure><h2 id="二、本质"><a href="#二、本质" class="headerlink" title="二、本质"></a>二、本质</h2><p>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p><p>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><p>简言之,const 保证简单类型数据变量指向的内存地址的数据不变,保证复杂类型数据所指向的内存地址中的地址不变,而数据结构是否变化则不能保证.</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">const foo = &#123;&#125;;<br><span class="hljs-regexp">//</span> 为 foo 添加一个属性，可以成功<br>foo.prop = <span class="hljs-number">123</span>;<br>foo.prop <span class="hljs-regexp">//</span> <span class="hljs-number">123</span><br><span class="hljs-regexp">//</span> 将 foo 指向另一个对象，就会报错<br>foo = &#123;&#125;; <span class="hljs-regexp">//</span> TypeError: <span class="hljs-string">&quot;foo&quot;</span> is read-only<br></code></pre></td></tr></table></figure><h2 id="三、ES6-声明变量的六种方法"><a href="#三、ES6-声明变量的六种方法" class="headerlink" title="三、ES6 声明变量的六种方法"></a>三、ES6 声明变量的六种方法</h2><p>ES5: var 和 function<br>ES6: var function let const import class</p><h2 id="四、顶层对象"><a href="#四、顶层对象" class="headerlink" title="四、顶层对象"></a>四、顶层对象</h2><p>顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p><p>(1) 没法在编译时就报出变量未声明的错误，只有运行时才能知道<br>(2) 容易不知不觉地就创建了全局变量<br>(3) 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。<br>(4) window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p><p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = <span class="hljs-number">1</span>;<br><span class="hljs-regexp">//</span> 如果在 Node 的 REPL 环境，可以写成 global.a<br><span class="hljs-regexp">//</span> 或者采用通用方法，写成 this.a<br>window.a <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>let b = <span class="hljs-number">1</span>;<br>window.b <span class="hljs-regexp">//</span> undefined<br></code></pre></td></tr></table></figure><h4 id="五、globalThis-对象"><a href="#五、globalThis-对象" class="headerlink" title="五、globalThis 对象"></a>五、globalThis 对象</h4><p>(1) 顶层对象在各种实现里面是不统一的。</p><p>浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window。<br>浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self。<br>Node 里面，顶层对象是 global，但其他环境都不支持。</p><p>(2) 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 this 变量，但是有局限性。</p><p>全局环境中，this 会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。<br>函数里面的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this 会指向顶层对象。但是，严格模式下，这时 this 会返回 undefined。<br>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么 eval、new Function 这些方法都可能无法使用。</p><p>ES2020 在语言标准的层面，引入 globalThis 作为顶层对象。也就是说，任何环境下，globalThis 都是存在的，都可以从它拿到顶层对象，指向全局环境下的 this。</p><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/let">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6-let和const（上）</title>
    <link href="/article/1de5214c.html"/>
    <url>/article/1de5214c.html</url>
    
    <content type="html"><![CDATA[<img src="/article/1de5214c/banner.jpg" class="" title="image"><h1 id="let-关键字与-const-关键字"><a href="#let-关键字与-const-关键字" class="headerlink" title="let 关键字与 const 关键字"></a>let 关键字与 const 关键字</h1><p>let 关键字和 const 关键字是 ES6 新增的用于变量定义的新特性</p><h2 id="一、-let-声明的变量只在块级作用域有效"><a href="#一、-let-声明的变量只在块级作用域有效" class="headerlink" title="一、 let 声明的变量只在块级作用域有效"></a>一、 let 声明的变量只在块级作用域有效</h2><p>块级作用域大概可以理解为一对花括号{}内</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&#123;<br>  let a1 = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> b1 = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;a1&quot;</span> + a1); <span class="hljs-comment">// ReferenceError: a is not defined.</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;b1&quot;</span> + b1); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="let-适用于-for-循环中的变量定义"><a href="#let-适用于-for-循环中的变量定义" class="headerlink" title="let 适用于 for 循环中的变量定义"></a>let 适用于 for 循环中的变量定义</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i); <span class="hljs-comment">// ReferenceError: i is not defined</span><br></code></pre></td></tr></table></figure><h4 id="let-与-var-区别"><a href="#let-与-var-区别" class="headerlink" title="let 与 var 区别"></a>let 与 var 区别</h4><p>let 作用于块级，而 var 作用于全局，经过 for 循环，let 声明的 i 会取得 6，var 声明的 i 会取得全局的 10</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>for (var i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++) &#123;</span><br>  a[i] <span class="hljs-operator">=</span> function () &#123;<br>    console.log(i)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>&#125;<br>a[<span class="hljs-number">6</span>]()<span class="hljs-comment">; // 10</span><br><br>var a <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br>for (let i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 10; i++) &#123;</span><br>  a[i] <span class="hljs-operator">=</span> function () &#123;<br>    console.log(i)<span class="hljs-comment">;</span><br>  &#125;<span class="hljs-comment">;</span><br>&#125;<br>a[<span class="hljs-number">6</span>]()<span class="hljs-comment">; // 6</span><br></code></pre></td></tr></table></figure><h2 id="二、let-不存在变量提升"><a href="#二、let-不存在变量提升" class="headerlink" title="二、let 不存在变量提升"></a>二、let 不存在变量提升</h2><p>var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 undefined。let 命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// var 的情况</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo); <span class="hljs-comment">// 输出undefined</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// let 的情况</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(bar); <span class="hljs-comment">// 报错ReferenceError</span><br>let bar = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h2 id="三、暂时性死区（temporal-dead-zone，简称-TDZ）"><a href="#三、暂时性死区（temporal-dead-zone，简称-TDZ）" class="headerlink" title="三、暂时性死区（temporal dead zone，简称 TDZ）"></a>三、暂时性死区（temporal dead zone，简称 TDZ）</h2><p>只要块级作用域内存在 let 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span><br>  <span class="hljs-keyword">let</span> tmp;<br>&#125;<br></code></pre></td></tr></table></figure><p>ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-comment">// TDZ开始</span><br>  tmp = <span class="hljs-string">&#x27;abc&#x27;</span>; <span class="hljs-comment">// ReferenceError</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp); <span class="hljs-comment">// ReferenceError</span><br>  let tmp; <span class="hljs-comment">// TDZ结束</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp); <span class="hljs-comment">// undefined</span><br>  tmp = <span class="hljs-number">123</span>;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp); <span class="hljs-comment">// 123</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样的设计是为了养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p><h2 id="四、不允许重复声明"><a href="#四、不允许重复声明" class="headerlink" title="四、不允许重复声明"></a>四、不允许重复声明</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 报错</span><br><span class="hljs-function">function <span class="hljs-title">func</span>()</span> &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">// 报错</span><br><span class="hljs-function">function <span class="hljs-title">func</span>()</span> &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不能在函数内部重新声明参数</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> <span class="hljs-keyword">func</span>(arg) &#123;<br>  let arg;<br>&#125;<br><span class="hljs-keyword">func</span>() <span class="hljs-regexp">//</span> 报错<br><span class="hljs-keyword">function</span> <span class="hljs-keyword">func</span>(arg) &#123;<br>  &#123;<br>    let arg;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">func</span>() <span class="hljs-regexp">//</span> 不报错<br></code></pre></td></tr></table></figure><h4 id="示例与内容均来自阮一峰-ES6-教程"><a href="#示例与内容均来自阮一峰-ES6-教程" class="headerlink" title="示例与内容均来自阮一峰 ES6 教程"></a>示例与内容均来自<a href="https://es6.ruanyifeng.com/#docs/let">阮一峰 ES6 教程</a></h4>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
      <category>Work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
